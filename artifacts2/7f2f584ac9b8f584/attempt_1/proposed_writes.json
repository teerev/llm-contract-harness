{
  "summary": "Added mazegen/solve.py implementing a pure, deterministic BFS maze solver that returns the shortest path using sorted neighbor exploration and handles no-path cases.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nfrom collections import deque\nfrom typing import Deque, Dict, Iterable, List, Optional, Set, Tuple\n\nfrom .types import Maze, Position, Solution\n\n\ndef _build_adjacency(maze: Maze) -> Dict[Position, List[Position]]:\n    \"\"\"Build an undirected adjacency list from maze.passages.\n\n    Neighbors are stored in deterministic order (sorted by (row, col)).\n    \"\"\"\n    adj: Dict[Position, Set[Position]] = {}\n\n    for a, b in maze.passages:\n        adj.setdefault(a, set()).add(b)\n        adj.setdefault(b, set()).add(a)\n\n    # Ensure start/end exist as keys even if isolated (defensive)\n    adj.setdefault(maze.start, set())\n    adj.setdefault(maze.end, set())\n\n    ordered: Dict[Position, List[Position]] = {}\n    for node, nbrs in adj.items():\n        ordered[node] = sorted(nbrs, key=lambda p: (p.row, p.col))\n    return ordered\n\n\ndef solve(maze: Maze) -> Solution:\n    \"\"\"Solve a maze using breadth-first search (BFS).\n\n    Returns the shortest path from maze.start to maze.end (inclusive) if found.\n    The function is pure and deterministic.\n    \"\"\"\n    if maze.start == maze.end:\n        return Solution(found=True, path=(maze.start,))\n\n    adj = _build_adjacency(maze)\n\n    q: Deque[Position] = deque([maze.start])\n    visited: Set[Position] = {maze.start}\n    parent: Dict[Position, Optional[Position]] = {maze.start: None}\n\n    while q:\n        cur = q.popleft()\n        if cur == maze.end:\n            break\n\n        for nxt in adj.get(cur, []):\n            if nxt in visited:\n                continue\n            visited.add(nxt)\n            parent[nxt] = cur\n            q.append(nxt)\n\n    if maze.end not in parent:\n        return Solution(found=False, path=())\n\n    # Reconstruct path from end to start\n    rev_path: List[Position] = []\n    node: Optional[Position] = maze.end\n    while node is not None:\n        rev_path.append(node)\n        node = parent.get(node)\n\n    rev_path.reverse()\n    return Solution(found=True, path=tuple(rev_path))\n",
      "path": "mazegen/solve.py"
    }
  ]
}
