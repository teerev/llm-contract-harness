{
  "summary": "Added lsysviz/render.py implementing deterministic PNG rendering of segments with bounding-box fit and padding, using Pillow when available and a pure-Python PNG fallback when Pillow is not installed.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nfrom typing import Iterable\n\nfrom .types import Segment\n\n\ndef render_to_png(segments: list[Segment], width: int, height: int, output_path: str) -> None:\n    \"\"\"Render a list of line segments to a PNG image.\n\n    Creates a white RGB image of the given dimensions, fits all segments into the\n    image with padding, draws them as black 1px lines, and saves to output_path.\n\n    The output is deterministic for identical inputs.\n    \"\"\"\n\n    if width <= 0 or height <= 0:\n        raise ValueError(\"width and height must be positive\")\n\n    # Try Pillow first (preferred). If not available, fall back to a minimal\n    # pure-Python PNG writer + line rasterizer.\n    try:\n        from PIL import Image, ImageDraw  # type: ignore\n\n        img = Image.new(\"RGB\", (width, height), (255, 255, 255))\n        if segments:\n            draw = ImageDraw.Draw(img)\n            mapped = _map_segments_to_image(segments, width, height, margin_frac=0.10)\n            for x0, y0, x1, y1 in mapped:\n                # Use integer pixel coordinates for determinism.\n                draw.line((x0, y0, x1, y1), fill=(0, 0, 0), width=1)\n\n        # Ensure deterministic encoding: disable metadata and use fixed settings.\n        img.save(output_path, format=\"PNG\", optimize=False)\n        return\n    except ModuleNotFoundError:\n        pass\n\n    # Fallback: pure-Python deterministic PNG writer.\n    pixels = _new_white_pixels(width, height)\n    if segments:\n        mapped = _map_segments_to_image(segments, width, height, margin_frac=0.10)\n        for x0, y0, x1, y1 in mapped:\n            _draw_line_bresenham(pixels, width, height, x0, y0, x1, y1)\n\n    _write_png_rgb(output_path, width, height, pixels)\n\n\ndef _map_segments_to_image(\n    segments: Iterable[Segment],\n    width: int,\n    height: int,\n    margin_frac: float = 0.10,\n) -> list[tuple[int, int, int, int]]:\n    segs = list(segments)\n    if not segs:\n        return []\n\n    xs = [s.x0 for s in segs] + [s.x1 for s in segs]\n    ys = [s.y0 for s in segs] + [s.y1 for s in segs]\n    min_x, max_x = min(xs), max(xs)\n    min_y, max_y = min(ys), max(ys)\n\n    # Handle degenerate bounds.\n    span_x = max_x - min_x\n    span_y = max_y - min_y\n    if span_x == 0:\n        span_x = 1.0\n    if span_y == 0:\n        span_y = 1.0\n\n    # Padding in pixels.\n    pad_x = int(round(width * margin_frac))\n    pad_y = int(round(height * margin_frac))\n    inner_w = max(1, width - 2 * pad_x)\n    inner_h = max(1, height - 2 * pad_y)\n\n    # Uniform scale to preserve aspect ratio.\n    scale = min(inner_w / span_x, inner_h / span_y)\n\n    # Center within inner box.\n    content_w = span_x * scale\n    content_h = span_y * scale\n    offset_x = pad_x + (inner_w - content_w) / 2.0\n    offset_y = pad_y + (inner_h - content_h) / 2.0\n\n    def map_point(x: float, y: float) -> tuple[int, int]:\n        # Map to image coordinates; y increases downward.\n        px = offset_x + (x - min_x) * scale\n        py = offset_y + (y - min_y) * scale\n        # Deterministic rounding.\n        ix = int(round(px))\n        iy = int(round(py))\n        # Clamp to image bounds.\n        if ix < 0:\n            ix = 0\n        elif ix >= width:\n            ix = width - 1\n        if iy < 0:\n            iy = 0\n        elif iy >= height:\n            iy = height - 1\n        return ix, iy\n\n    out: list[tuple[int, int, int, int]] = []\n    for s in segs:\n        x0, y0 = map_point(s.x0, s.y0)\n        x1, y1 = map_point(s.x1, s.y1)\n        out.append((x0, y0, x1, y1))\n    return out\n\n\ndef _new_white_pixels(width: int, height: int) -> bytearray:\n    # RGB packed, row-major.\n    return bytearray(b\"\\xff\\xff\\xff\" * (width * height))\n\n\ndef _set_pixel(pixels: bytearray, width: int, height: int, x: int, y: int, rgb: tuple[int, int, int]) -> None:\n    if x < 0 or y < 0 or x >= width or y >= height:\n        return\n    i = (y * width + x) * 3\n    pixels[i] = rgb[0]\n    pixels[i + 1] = rgb[1]\n    pixels[i + 2] = rgb[2]\n\n\ndef _draw_line_bresenham(\n    pixels: bytearray,\n    width: int,\n    height: int,\n    x0: int,\n    y0: int,\n    x1: int,\n    y1: int,\n) -> None:\n    # Integer Bresenham line drawing.\n    dx = abs(x1 - x0)\n    dy = -abs(y1 - y0)\n    sx = 1 if x0 < x1 else -1\n    sy = 1 if y0 < y1 else -1\n    err = dx + dy\n\n    x, y = x0, y0\n    while True:\n        _set_pixel(pixels, width, height, x, y, (0, 0, 0))\n        if x == x1 and y == y1:\n            break\n        e2 = 2 * err\n        if e2 >= dy:\n            err += dy\n            x += sx\n        if e2 <= dx:\n            err += dx\n            y += sy\n\n\ndef _write_png_rgb(path: str, width: int, height: int, pixels: bytearray) -> None:\n    \"\"\"Write an RGB PNG deterministically (no ancillary chunks).\"\"\"\n\n    import struct\n    import zlib\n\n    def chunk(chunk_type: bytes, data: bytes) -> bytes:\n        length = struct.pack(\">I\", len(data))\n        crc = zlib.crc32(chunk_type)\n        crc = zlib.crc32(data, crc) & 0xFFFFFFFF\n        return length + chunk_type + data + struct.pack(\">I\", crc)\n\n    # Build raw scanlines with filter type 0 per row.\n    stride = width * 3\n    raw = bytearray()\n    for y in range(height):\n        raw.append(0)  # filter type 0\n        start = y * stride\n        raw.extend(pixels[start : start + stride])\n\n    # Deterministic zlib stream: fixed compression level and strategy.\n    compressed = zlib.compress(bytes(raw), level=9)\n\n    signature = b\"\\x89PNG\\r\\n\\x1a\\n\"\n    ihdr = struct.pack(\">IIBBBBB\", width, height, 8, 2, 0, 0, 0)  # 8-bit, truecolor\n    data = (\n        signature\n        + chunk(b\"IHDR\", ihdr)\n        + chunk(b\"IDAT\", compressed)\n        + chunk(b\"IEND\", b\"\")\n    )\n\n    with open(path, \"wb\") as f:\n        f.write(data)\n",
      "path": "lsysviz/render.py"
    }
  ]
}
