diff --git a/lsysviz/spec.py b/lsysviz/spec.py
index 2b0c1a7..c7f4a2d 100644
--- a/lsysviz/spec.py
+++ b/lsysviz/spec.py
@@ -1,12 +1,220 @@
-"""Spec helpers."""
+"""Frozen JSON input specification for deterministic L-system rendering.
+
+This module defines the minimal, strict JSON schema contract and provides
+deterministic parsing/validation.
+
+Contract (frozen):
+Required keys:
+  - axiom: string
+  - rules: object mapping single-character strings to replacement strings
+  - iterations: int >= 0
+  - angle_degrees: number
+  - step: number
+  - width: int > 0
+  - height: int > 0
+
+Optional keys (with defaults):
+  - margin: int >= 0 (default 0)
+  - background_rgba: [r,g,b,a] ints 0..255 (default [255,255,255,255])
+  - line_rgba: [r,g,b,a] ints 0..255 (default [0,0,0,255])
+  - line_width: int >= 1 (default 1)
+  - start_heading_degrees: number (default 0)
+
+Unknown keys are rejected.
+"""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Any, Dict, Mapping, Tuple
+
+
+class SpecError(ValueError):
+    """Raised when the input JSON does not conform to the frozen schema."""
+
+
+RGBA = Tuple[int, int, int, int]
+
+
+@dataclass(frozen=True)
+class LSystemSpec:
+    axiom: str
+    rules: Dict[str, str]
+    iterations: int
+    angle_degrees: float
+    step: float
+    width: int
+    height: int
+    margin: int = 0
+    background_rgba: RGBA = (255, 255, 255, 255)
+    line_rgba: RGBA = (0, 0, 0, 255)
+    line_width: int = 1
+    start_heading_degrees: float = 0.0
+
+
+_REQUIRED_KEYS = {
+    "axiom",
+    "rules",
+    "iterations",
+    "angle_degrees",
+    "step",
+    "width",
+    "height",
+}
+
+_OPTIONAL_KEYS = {
+    "margin",
+    "background_rgba",
+    "line_rgba",
+    "line_width",
+    "start_heading_degrees",
+}
+
+_ALL_KEYS = _REQUIRED_KEYS | _OPTIONAL_KEYS
+
+
+def _type_name(v: Any) -> str:
+    return type(v).__name__
+
+
+def _require_mapping(obj: Any, *, where: str) -> Mapping[str, Any]:
+    if not isinstance(obj, dict):
+        raise SpecError(f"{where} must be an object, got {_type_name(obj)}")
+    return obj
+
+
+def _require_str(v: Any, *, where: str) -> str:
+    if not isinstance(v, str):
+        raise SpecError(f"{where} must be a string, got {_type_name(v)}")
+    return v
+
+
+def _require_int(v: Any, *, where: str) -> int:
+    # bool is a subclass of int; reject it for determinism.
+    if isinstance(v, bool) or not isinstance(v, int):
+        raise SpecError(f"{where} must be an int, got {_type_name(v)}")
+    return v
+
+
+def _require_number(v: Any, *, where: str) -> float:
+    if isinstance(v, bool) or not isinstance(v, (int, float)):
+        raise SpecError(f"{where} must be a number, got {_type_name(v)}")
+    return float(v)
+
+
+def _require_rgba(v: Any, *, where: str) -> RGBA:
+    if not isinstance(v, (list, tuple)):
+        raise SpecError(f"{where} must be an array of 4 ints, got {_type_name(v)}")
+    if len(v) != 4:
+        raise SpecError(f"{where} must have length 4, got {len(v)}")
+    out = []
+    for i, c in enumerate(v):
+        ci = _require_int(c, where=f"{where}[{i}]")
+        if not (0 <= ci <= 255):
+            raise SpecError(f"{where}[{i}] must be in 0..255, got {ci}")
+        out.append(ci)
+    return (out[0], out[1], out[2], out[3])
+
+
+def _require_rules(v: Any, *, where: str) -> Dict[str, str]:
+    m = _require_mapping(v, where=where)
+    rules: Dict[str, str] = {}
+    for k, val in m.items():
+        if not isinstance(k, str):
+            raise SpecError(f"{where} keys must be strings, got {_type_name(k)}")
+        if len(k) != 1:
+            raise SpecError(f"{where} keys must be single-character strings, got {k!r}")
+        sval = _require_str(val, where=f"{where}[{k!r}]")
+        rules[k] = sval
+    return rules
+
+
+def parse_spec(obj: Any) -> LSystemSpec:
+    """Parse and validate a JSON-decoded object into a frozen LSystemSpec.
+
+    This function is strict:
+      - requires an object at the top level
+      - rejects unknown keys
+      - enforces types and numeric bounds
+      - rejects bool where int/number is expected
+    """
+
+    top = _require_mapping(obj, where="spec")
+
+    unknown = set(top.keys()) - _ALL_KEYS
+    if unknown:
+        raise SpecError(f"Unknown key(s): {', '.join(sorted(unknown))}")
+
+    missing = _REQUIRED_KEYS - set(top.keys())
+    if missing:
+        raise SpecError(f"Missing required key(s): {', '.join(sorted(missing))}")
+
+    axiom = _require_str(top.get("axiom"), where="axiom")
+    rules = _require_rules(top.get("rules"), where="rules")
+
+    iterations = _require_int(top.get("iterations"), where="iterations")
+    if iterations < 0:
+        raise SpecError(f"iterations must be >= 0, got {iterations}")
+
+    angle_degrees = _require_number(top.get("angle_degrees"), where="angle_degrees")
+    step = _require_number(top.get("step"), where="step")
+
+    width = _require_int(top.get("width"), where="width")
+    if width <= 0:
+        raise SpecError(f"width must be > 0, got {width}")
+
+    height = _require_int(top.get("height"), where="height")
+    if height <= 0:
+        raise SpecError(f"height must be > 0, got {height}")
+
+    margin = 0
+    if "margin" in top:
+        margin = _require_int(top.get("margin"), where="margin")
+        if margin < 0:
+            raise SpecError(f"margin must be >= 0, got {margin}")
+
+    background_rgba: RGBA = (255, 255, 255, 255)
+    if "background_rgba" in top:
+        background_rgba = _require_rgba(top.get("background_rgba"), where="background_rgba")
+
+    line_rgba: RGBA = (0, 0, 0, 255)
+    if "line_rgba" in top:
+        line_rgba = _require_rgba(top.get("line_rgba"), where="line_rgba")
+
+    line_width = 1
+    if "line_width" in top:
+        line_width = _require_int(top.get("line_width"), where="line_width")
+        if line_width < 1:
+            raise SpecError(f"line_width must be >= 1, got {line_width}")
+
+    start_heading_degrees = 0.0
+    if "start_heading_degrees" in top:
+        start_heading_degrees = _require_number(
+            top.get("start_heading_degrees"), where="start_heading_degrees"
+        )
+
+    return LSystemSpec(
+        axiom=axiom,
+        rules=rules,
+        iterations=iterations,
+        angle_degrees=angle_degrees,
+        step=step,
+        width=width,
+        height=height,
+        margin=margin,
+        background_rgba=background_rgba,
+        line_rgba=line_rgba,
+        line_width=line_width,
+        start_heading_degrees=start_heading_degrees,
+    )
