diff --git a/lsysviz/spec.py b/lsysviz/spec.py
index e69de29..b7b0c2a 100644
--- a/lsysviz/spec.py
+++ b/lsysviz/spec.py
@@ -0,0 +1,250 @@
+"""Frozen JSON input specification for deterministic L-system rendering.
+
+This module defines the minimal, strict schema for the renderer input.
+Unknown keys are rejected to prevent contract drift.
+
+This work order intentionally does NOT implement L-system expansion, turtle
+interpretation, rasterization, or PNG encoding.
+"""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Any, Dict, Mapping, Tuple
+
+
+RGBA = Tuple[int, int, int, int]
+
+
+@dataclass(frozen=True)
+class Spec:
+    # Required
+    axiom: str
+    rules: Dict[str, str]
+    iterations: int
+    angle_degrees: float
+    step: float
+    width: int
+    height: int
+
+    # Optional with defaults
+    margin: int = 0
+    background_rgba: RGBA = (255, 255, 255, 255)
+    line_rgba: RGBA = (0, 0, 0, 255)
+    line_width: int = 1
+    start_heading_degrees: float = 0.0
+
+
+class SpecValidationError(ValueError):
+    """Raised when the input JSON does not match the frozen schema."""
+
+
+_REQUIRED_KEYS = {
+    "axiom",
+    "rules",
+    "iterations",
+    "angle_degrees",
+    "step",
+    "width",
+    "height",
+}
+
+_OPTIONAL_KEYS = {
+    "margin",
+    "background_rgba",
+    "line_rgba",
+    "line_width",
+    "start_heading_degrees",
+}
+
+_ALL_KEYS = _REQUIRED_KEYS | _OPTIONAL_KEYS
+
+
+def _err(msg: str) -> SpecValidationError:
+    return SpecValidationError(msg)
+
+
+def _require_type(name: str, value: Any, typ: type) -> None:
+    if not isinstance(value, typ):
+        raise _err(f"{name} must be {typ.__name__}")
+
+
+def _require_number(name: str, value: Any) -> float:
+    # bool is a subclass of int; reject it for determinism.
+    if isinstance(value, bool) or not isinstance(value, (int, float)):
+        raise _err(f"{name} must be a number")
+    return float(value)
+
+
+def _require_int(name: str, value: Any) -> int:
+    if isinstance(value, bool) or not isinstance(value, int):
+        raise _err(f"{name} must be an int")
+    return int(value)
+
+
+def _require_rgba(name: str, value: Any) -> RGBA:
+    if not isinstance(value, (list, tuple)):
+        raise _err(f"{name} must be an array of 4 ints")
+    if len(value) != 4:
+        raise _err(f"{name} must have length 4")
+    out = []
+    for i, v in enumerate(value):
+        if isinstance(v, bool) or not isinstance(v, int):
+            raise _err(f"{name}[{i}] must be an int")
+        if v < 0 or v > 255:
+            raise _err(f"{name}[{i}] must be in 0..255")
+        out.append(int(v))
+    return (out[0], out[1], out[2], out[3])
+
+
+def _validate_rules(rules: Any) -> Dict[str, str]:
+    if not isinstance(rules, dict):
+        raise _err("rules must be an object mapping single-character strings to strings")
+    out: Dict[str, str] = {}
+    for k, v in rules.items():
+        if not isinstance(k, str):
+            raise _err("rules keys must be strings")
+        if len(k) != 1:
+            raise _err("rules keys must be single-character strings")
+        if not isinstance(v, str):
+            raise _err("rules values must be strings")
+        out[k] = v
+    return out
+
+
+def parse_spec(obj: Mapping[str, Any]) -> Spec:
+    """Parse and validate a JSON-decoded object into a frozen Spec.
+
+    Strictness rules:
+    - obj must be a mapping (dict-like)
+    - required keys must be present
+    - unknown keys are rejected
+    - types and numeric constraints are enforced
+    """
+    if not isinstance(obj, Mapping):
+        raise _err("spec root must be an object")
+
+    keys = set(obj.keys())
+    missing = _REQUIRED_KEYS - keys
+    if missing:
+        raise _err(f"missing required keys: {', '.join(sorted(missing))}")
+    unknown = keys - _ALL_KEYS
+    if unknown:
+        raise _err(f"unknown keys: {', '.join(sorted(unknown))}")
+
+    axiom = obj.get("axiom")
+    _require_type("axiom", axiom, str)
+
+    rules = _validate_rules(obj.get("rules"))
+
+    iterations = _require_int("iterations", obj.get("iterations"))
+    if iterations < 0:
+        raise _err("iterations must be >= 0")
+
+    angle_degrees = _require_number("angle_degrees", obj.get("angle_degrees"))
+    step = _require_number("step", obj.get("step"))
+
+    width = _require_int("width", obj.get("width"))
+    if width <= 0:
+        raise _err("width must be > 0")
+
+    height = _require_int("height", obj.get("height"))
+    if height <= 0:
+        raise _err("height must be > 0")
+
+    margin = 0
+    if "margin" in obj:
+        margin = _require_int("margin", obj.get("margin"))
+        if margin < 0:
+            raise _err("margin must be >= 0")
+
+    background_rgba: RGBA = (255, 255, 255, 255)
+    if "background_rgba" in obj:
+        background_rgba = _require_rgba("background_rgba", obj.get("background_rgba"))
+
+    line_rgba: RGBA = (0, 0, 0, 255)
+    if "line_rgba" in obj:
+        line_rgba = _require_rgba("line_rgba", obj.get("line_rgba"))
+
+    line_width = 1
+    if "line_width" in obj:
+        line_width = _require_int("line_width", obj.get("line_width"))
+        if line_width < 1:
+            raise _err("line_width must be >= 1")
+
+    start_heading_degrees = 0.0
+    if "start_heading_degrees" in obj:
+        start_heading_degrees = _require_number(
+            "start_heading_degrees", obj.get("start_heading_degrees")
+        )
+
+    return Spec(
+        axiom=axiom,
+        rules=rules,
+        iterations=iterations,
+        angle_degrees=angle_degrees,
+        step=step,
+        width=width,
+        height=height,
+        margin=margin,
+        background_rgba=background_rgba,
+        line_rgba=line_rgba,
+        line_width=line_width,
+        start_heading_degrees=start_heading_degrees,
+    )
