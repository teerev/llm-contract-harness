{
  "id": "WO-04",
  "title": "Implement deterministic maze generation",
  "intent": "Create mazegen/generate.py with a pure function that generates a perfect rectangular maze using recursive backtracker with a seeded RNG.",
  "allowed_files": [
    "mazegen/generate.py",
    "mazegen/types.py"
  ],
  "forbidden": [
    "Do not modify mazegen/types.py",
    "Do not modify any other existing files",
    "Do not use the global random module state — use random.Random(seed) for a local instance"
  ],
  "acceptance_commands": [
    "python -c \"from mazegen.generate import generate; from mazegen.types import Position; m = generate(width=4, height=4, seed=42); assert m.width == 4 and m.height == 4; assert m.start == Position(0, 0); assert m.end == Position(3, 3); assert len(m.passages) > 0\"",
    "python -c \"from mazegen.generate import generate; m1 = generate(width=4, height=4, seed=42); m2 = generate(width=4, height=4, seed=42); assert m1.passages == m2.passages, 'not deterministic'\""
  ],
  "context_files": [
    "mazegen/generate.py",
    "mazegen/types.py"
  ],
  "notes": "Define: generate(width: int, height: int, seed: int) -> Maze. Use a recursive-backtracker (depth-first) algorithm: start from cell (0,0), use a local random.Random(seed) instance to shuffle neighbor order at each step, carve passages by adding (min(a,b), max(a,b)) to a set. The result is a perfect maze (spanning tree — exactly one path between any two cells). Start is always Position(0, 0), end is always Position(height-1, width-1). The number of passages in a perfect maze of W x H is W*H - 1. Store passages as a frozenset. Do NOT modify mazegen/types.py — it is provided for reference only. Do NOT use the global random state (random.seed, random.shuffle etc.) — always create a local random.Random(seed) instance."
}
