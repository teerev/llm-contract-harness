{
  "id": "WO-05",
  "title": "Implement maze solver using BFS",
  "intent": "Create mazegen/solve.py with a function that solves a maze using breadth-first search, returning the shortest path.",
  "allowed_files": [
    "mazegen/solve.py",
    "mazegen/types.py"
  ],
  "forbidden": [
    "Do not modify mazegen/types.py",
    "Do not modify any other existing files"
  ],
  "acceptance_commands": [
    "python -c \"from mazegen.generate import generate; from mazegen.solve import solve; m = generate(width=5, height=5, seed=42); sol = solve(m); assert sol.found; assert sol.path[0] == m.start; assert sol.path[-1] == m.end; assert len(sol.path) >= 2\"",
    "python -c \"from mazegen.generate import generate; from mazegen.solve import solve; m = generate(width=5, height=5, seed=42); sol = solve(m); p = sol.path; assert all(abs(p[i].row - p[i+1].row) + abs(p[i].col - p[i+1].col) == 1 and (min(p[i], p[i+1]), max(p[i], p[i+1])) in m.passages for i in range(len(p) - 1)), 'invalid path'\""
  ],
  "context_files": [
    "mazegen/solve.py",
    "mazegen/types.py"
  ],
  "notes": "Define: solve(maze: Maze) -> Solution. Use breadth-first search (BFS) from maze.start to maze.end. Build an adjacency mapping from maze.passages: for each (a, b) in passages, a connects to b and b connects to a. Explore neighbors in a deterministic order (sorted by (row, col)) to ensure the same maze always produces the same solution path. If a path is found, return Solution(found=True, path=tuple_of_positions_from_start_to_end). If no path exists (should not happen for a perfect maze, but handle it), return Solution(found=False, path=()). The function must be pure and deterministic. Do NOT modify mazegen/types.py."
}
