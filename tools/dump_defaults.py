#!/usr/bin/env python3
"""Generate docs/CONFIG_DEFAULTS.md from planner and factory defaults modules.

Usage:
    python tools/dump_defaults.py              # writes docs/CONFIG_DEFAULTS.md
    python tools/dump_defaults.py --stdout     # prints to stdout instead
    python tools/dump_defaults.py --check      # exits non-zero if file is stale

The structured comment convention parsed from each defaults module:
    NAME: type = value  # cat:<category> [det] [safety] [— description]

Tags:
    cat:<word>   — category (model, timeout, retries, polling, paths, limits, etc.)
    det          — determinism-sensitive (changing breaks reproducibility)
    safety       — safety invariant (must not be exposed via CLI)
    — <text>     — human-readable description
"""

from __future__ import annotations

import ast
import importlib
import inspect
import os
import re
import sys
import types
from dataclasses import dataclass

# Ensure the project root is on sys.path so planner/factory are importable.
_PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if _PROJECT_ROOT not in sys.path:
    sys.path.insert(0, _PROJECT_ROOT)


# ---------------------------------------------------------------------------
# Parsing
# ---------------------------------------------------------------------------

_TAG_RE = re.compile(
    r"#\s*cat:(\w+)"       # required: cat:<category>
    r"(?: (det))?"         # optional: det
    r"(?: (safety))?"      # optional: safety
    r"(?:\s*—\s*(.*))?"    # optional: — description
)


@dataclass
class DefaultEntry:
    name: str
    value_repr: str
    type_str: str
    category: str
    determinism: bool
    safety: bool
    description: str


def _repr_truncated(value: object, max_len: int = 120) -> str:
    """repr() with truncation for large collections.

    frozenset/set values are sorted for deterministic output across
    Python invocations (hash randomization changes iteration order).
    """
    if isinstance(value, frozenset):
        r = f"frozenset({sorted(value)!r})"
    elif isinstance(value, set):
        r = f"{{{', '.join(repr(v) for v in sorted(value))}}}"
    else:
        r = repr(value)
    if len(r) > max_len:
        return r[: max_len - 3] + "..."
    return r


def _extract_entries(module: types.ModuleType) -> list[DefaultEntry]:
    """Extract DefaultEntry list from a defaults module by reading its source."""
    entries: list[DefaultEntry] = []
    source = inspect.getsource(module)

    # Parse the AST to find all module-level assignments with type annotations
    tree = ast.parse(source)
    # Build a line→source mapping for comment extraction
    lines = source.splitlines()

    for node in ast.iter_child_nodes(tree):
        if not isinstance(node, (ast.AnnAssign, ast.Assign)):
            continue

        # Get the name
        if isinstance(node, ast.AnnAssign) and isinstance(node.target, ast.Name):
            name = node.target.id
        elif isinstance(node, ast.Assign) and len(node.targets) == 1 and isinstance(node.targets[0], ast.Name):
            name = node.targets[0].id
        else:
            continue

        # Skip private/dunder names
        if name.startswith("_"):
            continue

        # Get the runtime value
        value = getattr(module, name, None)
        if value is None and not hasattr(module, name):
            continue

        type_str = type(value).__name__
        value_repr = _repr_truncated(value)

        # Find the trailing comment on the first line of this statement
        first_line = lines[node.lineno - 1] if node.lineno <= len(lines) else ""
        m = _TAG_RE.search(first_line)

        category = m.group(1) if m else "unknown"
        determinism = bool(m and m.group(2))
        safety = bool(m and m.group(3))
        description = (m.group(4) or "").strip() if m else ""

        entries.append(DefaultEntry(
            name=name,
            value_repr=value_repr,
            type_str=type_str,
            category=category,
            determinism=determinism,
            safety=safety,
            description=description,
        ))

    return entries


# ---------------------------------------------------------------------------
# Markdown generation
# ---------------------------------------------------------------------------


def _generate_markdown(
    module_entries: list[tuple[str, str, list[DefaultEntry]]],
) -> str:
    """Generate the full Markdown document.

    *module_entries* is a list of (subsystem_name, module_path, entries).
    """
    parts: list[str] = [
        "<!-- AUTO-GENERATED by tools/dump_defaults.py — do not hand-edit -->\n",
        "# Configuration Defaults Reference\n",
        (
            "This document is generated from the `defaults.py` modules in each\n"
            "subsystem. To regenerate:\n"
            "\n"
            "```\n"
            "python tools/dump_defaults.py\n"
            "```\n"
        ),
    ]

    for subsystem, mod_path, entries in module_entries:
        parts.append(f"## {subsystem} (`{mod_path}`)\n")
        parts.append(
            "| Name | Value | Type | Category | Det. | Safety | Description |\n"
            "|------|-------|------|----------|------|--------|-------------|\n"
        )
        for e in entries:
            det = "yes" if e.determinism else ""
            safe = "yes" if e.safety else ""
            # Escape pipes in value_repr for Markdown table safety
            val = e.value_repr.replace("|", "\\|")
            parts.append(
                f"| `{e.name}` | `{val}` | {e.type_str} "
                f"| {e.category} | {det} | {safe} | {e.description} |\n"
            )
        parts.append("\n")

    return "".join(parts)


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

_MODULES = [
    ("Planner", "planner.defaults"),
    ("Factory", "factory.defaults"),
]

_OUTPUT_PATH = os.path.join(
    os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
    "docs",
    "CONFIG_DEFAULTS.md",
)


def generate() -> str:
    """Import defaults modules, extract entries, return Markdown string."""
    module_entries: list[tuple[str, str, list[DefaultEntry]]] = []
    for subsystem, mod_path in _MODULES:
        mod = importlib.import_module(mod_path)
        entries = _extract_entries(mod)
        module_entries.append((subsystem, mod_path, entries))
    return _generate_markdown(module_entries)


def main() -> int:
    check_mode = "--check" in sys.argv
    stdout_mode = "--stdout" in sys.argv

    markdown = generate()

    if stdout_mode:
        sys.stdout.write(markdown)
        return 0

    if check_mode:
        if not os.path.isfile(_OUTPUT_PATH):
            print(f"FAIL: {_OUTPUT_PATH} does not exist. Run: python tools/dump_defaults.py", file=sys.stderr)
            return 1
        with open(_OUTPUT_PATH, "r", encoding="utf-8") as fh:
            existing = fh.read()
        if existing != markdown:
            print(f"FAIL: {_OUTPUT_PATH} is stale. Run: python tools/dump_defaults.py", file=sys.stderr)
            return 1
        print(f"OK: {_OUTPUT_PATH} is up to date.")
        return 0

    # Default: write the file
    os.makedirs(os.path.dirname(_OUTPUT_PATH), exist_ok=True)
    with open(_OUTPUT_PATH, "w", encoding="utf-8") as fh:
        fh.write(markdown)
    print(f"Wrote {_OUTPUT_PATH} ({len(markdown)} bytes)")
    return 0


if __name__ == "__main__":
    sys.exit(main())
