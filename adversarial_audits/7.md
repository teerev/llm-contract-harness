# Planner → Factory Contract Boundary Audit

Field-by-field analysis of the work order JSON contract: what the factory
trusts, what it validates, what it blindly accepts, and where planner
control leaks into safety or execution semantics.

---

## The Contract Surface

The work order JSON (`WorkOrder` in `factory/schemas.py:86-97`) has
these fields:

```python
class WorkOrder(BaseModel):
    id: str
    title: str
    intent: str
    preconditions: list[Condition] = []
    postconditions: list[Condition] = []
    allowed_files: list[str]
    forbidden: list[str]
    acceptance_commands: list[str]
    context_files: list[str]
    notes: Optional[str] = None
    verify_exempt: bool = False
```

Each field is classified below.

---

## 1. Field-by-Field Trust Analysis

### `id` — BLINDLY ACCEPTED

**Factory validation:** None. The `id` field is a plain `str` with no
validator. It's not even checked for format. The planner's E001 check
(`WO-NN` contiguity) does not run in the factory.

**How it's used:** Stored in `run_summary.json` as `work_order_id`
(`run.py:167, 209`). Not used for any runtime decision.

**Risk:** None. Cosmetic field. But a hand-crafted work order with
`"id": "../../etc/passwd"` would appear in the summary artifact with
that string. No path construction uses it.

**Trust level:** Fully trusted (accepted without validation).

---

### `title` — BLINDLY ACCEPTED

**Factory validation:** None. Plain string, no constraints.

**How it's used:** Injected into the SE prompt
(`nodes_se.py:137`: `.replace("{{TITLE}}", work_order.title)`).
The LLM sees it as a heading. Not used for any runtime decision.

**Risk:** Prompt injection. A `title` containing adversarial prompt
instructions is injected verbatim into the SE LLM prompt. See `4.md` V6.
No factory code validates, sanitizes, or escapes `title`.

**Trust level:** Fully trusted (accepted without validation). Influences
LLM behavior via prompt.

---

### `intent` — BLINDLY ACCEPTED

**Factory validation:** None. Same as `title`.

**How it's used:** Injected into the SE prompt
(`nodes_se.py:138`: `.replace("{{INTENT}}", work_order.intent)`).

**Risk:** Identical to `title`. Prompt injection vector.

**Trust level:** Fully trusted. Influences LLM behavior.

---

### `preconditions` — VALIDATED (paths only), TRUSTED (semantics)

**Factory validation:**
- Path validation via `_validate_relative_path` on each `Condition.path`
  (`schemas.py:76-79`). Rejects absolute paths, `..`, NUL, etc.
- `kind` is restricted to `Literal["file_exists", "file_absent"]`
  (`schemas.py:73`).

**How it's used:** SE node checks each precondition against the
filesystem before calling the LLM (`nodes_se.py:168-213`). A failed
precondition produces `FailureBrief(stage="preflight")`.

**What is NOT validated:**
- Whether preconditions are *reasonable* (e.g., a precondition
  `file_exists("scripts/verify.sh")` is trusted to be a meaningful
  dependency, but the factory has no way to verify that the work order
  actually depends on that file).
- Whether preconditions are *satisfiable in context* (the factory doesn't
  know about prior work orders or the plan sequence).

**Risk:** Low. Preconditions can cause a run to fail (if unsatisfied) but
cannot cause writes or command execution. A malicious precondition on a
nonexistent file blocks the run but causes no damage.

**Trust level:** Partially trusted. Paths validated; semantic meaning
accepted without verification.

---

### `postconditions` — VALIDATED (structure), TRUSTED (semantics)

**Factory validation:**
- Path validation via `_validate_relative_path`.
- `kind` restricted to `file_exists` only (`schemas.py:117-130`).

**How it's used:** PO node checks each postcondition after TR writes,
before acceptance commands (`nodes_po.py:121-143`). A missing file
produces `FailureBrief(stage="acceptance_failed")`.

**What is NOT validated:**
- Whether postcondition paths are a subset of `allowed_files` (the
  planner validator checks this via E103, but the factory does not).
  A postcondition on a file outside `allowed_files` is accepted by the
  factory. The LLM cannot create that file (TR scope check blocks it),
  so the postcondition will always fail. This is a denial-of-service:
  the work order can never PASS.

**Risk:** Low. Can cause permanent failure but not data corruption.

**Trust level:** Partially trusted. Structure validated; consistency
with `allowed_files` is NOT cross-checked.

---

### `allowed_files` — VALIDATED (paths), CRITICAL TRUST

**Factory validation:**
- Path validation via `_validate_relative_path` (`schemas.py:99-102`).

**How it's used:** This is the **write scope**. TR uses it as the
allowlist for file writes (`nodes_tr.py:100, 121`). Every proposed
write path must be in this set. This is the primary safety boundary
for filesystem writes.

**What is NOT validated:**
- Whether the paths are *reasonable for the work order's intent*. A
  work order with `allowed_files: ["scripts/verify.sh", "setup.py",
  "requirements.txt", "Makefile", ...]` gives the SE LLM permission
  to rewrite critical infrastructure files. The factory does not limit
  the breadth of `allowed_files`.
- Whether `allowed_files` overlaps with prior work orders' outputs.
  The factory has no knowledge of the plan sequence.

**Risk:** High. The planner controls which files the SE LLM can modify.
An adversarial planner can grant the LLM write access to any file in the
repo via `allowed_files`. The factory's scope check is effective against
an adversarial SE LLM (which tries to write outside scope), but it is
ineffective against an adversarial planner (which sets the scope to
include sensitive files).

**Trust level:** Fully trusted. The planner defines the blast radius.
The factory enforces it mechanically but has no opinion on whether the
scope is appropriate.

---

### `forbidden` — BLINDLY ACCEPTED (prompt only)

**Factory validation:** None. `forbidden` is `list[str]` with no
validators. The strings are not even required to be non-empty.

**How it's used:** Injected into the SE prompt as a "Forbidden" section
(`nodes_se.py:98-100`):
```python
if work_order.forbidden:
    items = "\n".join(f"  - {f}" for f in work_order.forbidden)
    forbidden = f"## Forbidden\n{items}\n\n"
```

The factory does **not** enforce `forbidden` constraints mechanically.
If `forbidden` says "Do not modify __init__.py", and the LLM writes to
`__init__.py` (which is in `allowed_files`), the factory accepts the
write. `forbidden` is guidance for the LLM, not a constraint for the
factory.

**Risk:** Medium. Operators may believe `forbidden` is enforced. It is
not. It is a natural-language suggestion injected into a prompt, with
zero mechanical backing.

**Trust level:** Fully trusted (not validated). Influences LLM behavior
only. No enforcement.

---

### `acceptance_commands` — VALIDATED (syntax), CRITICAL TRUST

**Factory validation:**
- Non-empty list check (`schemas.py:104-108`).
- At runtime, each command is split via `shlex.split`
  (`nodes_po.py:152`). Parse failures are caught.

**How it's used:** PO executes every command via
`subprocess.run(shell=False)` with `cwd=repo_root`
(`nodes_po.py:174-180`). Exit code 0 = pass.

**What is NOT validated:**
- The factory does NOT re-run the planner's E003 (shell operator) or
  E006 (Python syntax) or E007 (shlex) checks. It relies on `shlex.split`
  succeeding at runtime. If the planner validation was skipped (hand-
  crafted work order), the factory runs whatever commands it gets.
- There is no restriction on which executables can be invoked, what
  arguments they receive, or what they do. See `4.md` V4.

**Risk:** Catastrophic. This is an arbitrary code execution surface.
The planner controls what commands run on the host. The factory's only
gate is that `shlex.split` must succeed. Everything else is trusted.

**Trust level:** Trusted for content, validated for parse-ability only.
Influences safety and execution semantics directly.

---

### `context_files` — VALIDATED (paths and count), SENSITIVE

**Factory validation:**
- Path validation via `_validate_relative_path` (`schemas.py:99-102`).
- Count check: max 10 entries (`schemas.py:111-115`).

**How it's used:** SE node reads these files from the repo and injects
their content into the LLM prompt (`nodes_se.py:30-64, 106-119`).

**What is NOT validated:**
- No check that `context_files` ⊇ `allowed_files`. The planner prompt
  says "MUST include all `allowed_files`" but the factory does not
  enforce this. A work order with `context_files: []` and
  `allowed_files: ["src/main.py"]` is accepted. The SE LLM won't see
  `src/main.py`'s current content or hash, so it will likely produce a
  wrong `base_sha256` and fail TR's hash check. But this is a functional
  failure, not a security issue.
- No check that context files are inside the repo (no
  `is_path_inside_repo` call — see `4.md` V3). Path validation rejects
  `..` and absolute paths, but symlinks inside the repo that point
  outside are followed.

**Risk:** Medium. Controls what the LLM sees. An adversarial planner
can cause the factory to read sensitive files via symlinks (information
disclosure). A careless planner can omit needed context, causing hash
mismatches and wasted attempts.

**Trust level:** Partially trusted. Paths validated; content and scope
of reads are trusted.

---

### `notes` — BLINDLY ACCEPTED (prompt only)

**Factory validation:** None. `Optional[str]`, no constraints.

**How it's used:** Injected verbatim into the SE prompt
(`nodes_se.py:103-104`):
```python
if work_order.notes:
    notes = f"## Notes\n{work_order.notes}\n\n"
```

**Risk:** Medium. Same as `title`/`intent` — prompt injection vector.
But `notes` is typically much longer and is the primary mechanism for
implementation guidance, making it the most valuable prompt-injection
target. An adversarial planner can embed arbitrary instructions in
`notes` that override the factory prompt template.

**Trust level:** Fully trusted (no validation). Influences LLM behavior
directly. No enforcement.

---

### `verify_exempt` — RECOMPUTED (M-01 fix)

**Factory validation:** Loaded as `bool` (Pydantic coerces). The value
in the JSON file is whatever the planner wrote.

**How it's used:** PO node checks `work_order.verify_exempt` to decide
whether to run full global verification or just `compileall`
(`nodes_po.py:83-86`).

**M-01 fix (planner side):** The planner unconditionally overwrites
`verify_exempt` based on `verify_contract` computation
(`compiler.py:335-351`). The LLM's value is never preserved.

**But the factory does NOT recompute it.** The factory reads the value
from the work order JSON and uses it directly. If someone hand-edits a
`WO-*.json` file and sets `verify_exempt: true`, the factory skips
global verification. There is no factory-side validation that
`verify_exempt` is consistent with any verify contract.

**Risk:** High. `verify_exempt: true` in a hand-crafted or tampered
work order skips the entire test suite. Only `python -m compileall -q .`
(syntax check) runs. The LLM can write any code that compiles.

The M-01 fix protects against the planner LLM setting this field, but
it does NOT protect against post-planner tampering of the JSON file.
The factory blindly trusts the value it reads from disk.

**Trust level:** Trusted from disk. Recomputed by planner (M-01) but
not recomputed by factory.

---

## 2. Planner-Controlled Fields That Influence Safety

| Field | Influences | Factory re-validates? | Risk if adversarial |
|-------|-----------|----------------------|---------------------|
| `allowed_files` | **Write scope** — which files the LLM can modify | Paths validated; scope breadth not checked | Planner controls blast radius |
| `acceptance_commands` | **Arbitrary code execution** on host | `shlex.split` only | Full host compromise |
| `verify_exempt` | **Global test suite bypass** | Not recomputed by factory | Skip all tests |
| `context_files` | **Information read scope** — which files are read and sent to LLM API | Paths validated; no `is_path_inside_repo` for reads | Information disclosure via symlinks |
| `notes` | **SE LLM behavior** via prompt injection | No validation | Override factory prompt instructions |
| `title` / `intent` | **SE LLM behavior** via prompt | No validation | Prompt injection |
| `forbidden` | **Nothing** (not enforced) | Not enforced at all | Operators falsely believe it's enforced |

---

## 3. Fields That Should Be Recomputed or Ignored But Are Not

### C1: `verify_exempt` should be recomputed by the factory

**Current state:** Trusted from the JSON file. M-01 ensures the planner
overwrites LLM values, but the factory reads the file as-is.

**Problem:** A tampered work order file (edited after planner compilation,
or hand-authored without the planner) can set `verify_exempt: true` and
bypass the entire test suite.

**What should happen:** The factory should either:
- Ignore `verify_exempt` entirely and recompute it from the verify
  contract (which requires knowing the full plan sequence — the factory
  doesn't have this), or
- Accept it but with a machine-readable audit trail that it was
  planner-computed, or
- At minimum, log a warning when `verify_exempt: true` is encountered.

**Severity:** High. Silent test-suite bypass.

### C2: `postconditions` should be cross-checked against `allowed_files`

**Current state:** The factory accepts postconditions on paths not in
`allowed_files`. The planner validates this (E103), but the factory does
not.

**Problem:** A postcondition `file_exists("lib/secret.py")` where
`lib/secret.py` is not in `allowed_files` creates an impossible work
order: the LLM cannot create the file (scope violation), so the
postcondition always fails, burning all retry attempts.

**What should happen:** The factory should reject postcondition paths
that are not in `allowed_files`. This is a one-line check.

**Severity:** Operational. Wasted retries on an impossible work order.

### C3: `context_files` should be validated for repo containment

**Current state:** Path validation rejects `..` and absolute paths, but
symlinks inside the repo that point outside are followed (see `4.md` V3).

**Problem:** A context file path that resolves (via symlink) to a
sensitive file outside the repo leaks its content to the LLM API and
artifact directory.

**What should happen:** `_read_context_files` should call
`is_path_inside_repo` (which uses `os.path.realpath`) on each path
before reading. This function already exists and is used by TR for write
paths.

**Severity:** High. Information disclosure.

### C4: `forbidden` should either be enforced or removed

**Current state:** Injected into the SE prompt as natural-language
guidance. Not enforced mechanically by any factory code.

**Problem:** Operators see `"forbidden": ["Do not modify __init__.py"]`
in the work order and believe it's a constraint. It's not. The LLM can
ignore it. The factory will accept the write if `__init__.py` is in
`allowed_files`.

**What should happen:** Either:
- Enforce `forbidden` as a TR write blocklist (reject writes to files
  or patterns mentioned in `forbidden`), or
- Document clearly that `forbidden` is non-binding prompt guidance and
  rename it to something like `guidance` or `soft_constraints` to avoid
  the false implication.

**Severity:** Medium. False sense of security for operators.

### C5: `id` should be format-validated

**Current state:** Plain string with no validation. The planner's E001
check (WO-NN format, contiguity) does not run in the factory.

**Problem:** A hand-crafted work order with `"id": ""` or
`"id": "drop table users;"` is accepted. The `id` appears in
`run_summary.json` but is not used for path construction (the `run_id`
is derived from the content hash, not the `id`). Low practical risk,
but the factory should at minimum reject empty IDs.

**Severity:** Low. Cosmetic integrity.

### C6: `acceptance_commands` should be sanitized or at minimum logged

**Current state:** Executed as-is via `subprocess.run(shell=False)`.
No content inspection, no allowlisting, no sandboxing.

**Problem:** See `4.md` V4. The planner controls what commands run on
the host.

**What should happen:** At minimum, the factory should log every
acceptance command before execution (it currently logs nothing — the
command is only recorded in the `acceptance_result.json` artifact after
execution). Ideally, the factory should offer an allowlist mode or
sandbox. Realistically, this requires containerization.

**Severity:** Catastrophic. Arbitrary code execution controlled by
planner.

---

## 4. Summary

The work order JSON is the trust boundary between planner and factory.
The factory's trust posture is:

**Validated and enforced:**
- File paths (relative, no traversal, no globs, no NUL) — for
  `allowed_files`, `context_files`, `preconditions`, `postconditions`
- Write scope (`allowed_files` → TR scope check)
- Write integrity (`base_sha256` → TR hash check)
- Path containment (`is_path_inside_repo` → TR, but NOT SE context reads)
- Postcondition kind (only `file_exists`)
- Acceptance commands parse-ability (`shlex.split`)
- Size limits (file write bytes, context file count)

**Accepted without validation:**
- `id`, `title`, `intent`, `notes`, `forbidden` — all plain strings
  with no constraints, injected into prompts or stored in artifacts
- `acceptance_commands` content — arbitrary commands executed on host
- `verify_exempt` — boolean read from disk, not recomputed

**Cross-checks that the planner does but the factory does not:**
- E001: ID format and contiguity
- E003: Shell operators in acceptance commands
- E006: Python syntax in `python -c` commands
- E103: Postcondition paths ⊆ `allowed_files`
- E105: `bash scripts/verify.sh` not in acceptance commands
- `verify_exempt` recomputation from `verify_contract`

The factory assumes the work order passed planner validation. If the
work order was hand-authored, modified after compilation, or produced by
a different tool, these planner-side checks are not replicated.

The most dangerous gap is `acceptance_commands`: the planner fully
controls what commands the factory executes on the host, and the factory's
only gate is `shlex.split` parse-ability. The second most dangerous is
`verify_exempt`: a single boolean in the JSON file, trusted from disk,
that disables the entire test suite.
