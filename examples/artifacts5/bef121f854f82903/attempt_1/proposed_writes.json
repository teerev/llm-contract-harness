{
  "summary": "Added worldsim/checkpoint.py implementing JSON-based save_checkpoint/load_checkpoint for lossless WorldState round-tripping with deterministic formatting (sorted keys, 2-space indent).",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nimport json\nfrom typing import Any, Dict, List, Tuple\n\nfrom worldsim.types import Agent, Position, WorldState\n\n\ndef _state_to_obj(state: WorldState) -> Dict[str, Any]:\n    agents: List[Dict[str, Any]] = []\n    for pos, agent in state.agents:\n        agents.append(\n            {\n                \"position\": {\"row\": int(pos.row), \"col\": int(pos.col)},\n                \"agent\": {\n                    \"energy\": int(agent.energy),\n                    \"age\": int(agent.age),\n                    \"direction\": int(agent.direction),\n                },\n            }\n        )\n\n    return {\n        \"version\": 1,\n        \"world\": {\n            \"width\": int(state.width),\n            \"height\": int(state.height),\n            \"step_number\": int(state.step_number),\n            \"seed\": int(state.seed),\n            \"agents\": agents,\n        },\n    }\n\n\ndef _obj_to_state(obj: Dict[str, Any]) -> WorldState:\n    if not isinstance(obj, dict):\n        raise ValueError(\"Checkpoint JSON root must be an object\")\n\n    version = obj.get(\"version\")\n    if version != 1:\n        raise ValueError(f\"Unsupported checkpoint version: {version!r}\")\n\n    world = obj.get(\"world\")\n    if not isinstance(world, dict):\n        raise ValueError(\"Checkpoint JSON must contain object key 'world'\")\n\n    width = world.get(\"width\")\n    height = world.get(\"height\")\n    step_number = world.get(\"step_number\")\n    seed = world.get(\"seed\")\n    agents_in = world.get(\"agents\")\n\n    if not isinstance(agents_in, list):\n        raise ValueError(\"Checkpoint 'world.agents' must be a list\")\n\n    agents_out: List[Tuple[Position, Agent]] = []\n    for i, item in enumerate(agents_in):\n        if not isinstance(item, dict):\n            raise ValueError(f\"Agent entry at index {i} must be an object\")\n\n        pos_obj = item.get(\"position\")\n        agent_obj = item.get(\"agent\")\n        if not isinstance(pos_obj, dict) or not isinstance(agent_obj, dict):\n            raise ValueError(f\"Agent entry at index {i} must contain 'position' and 'agent' objects\")\n\n        row = pos_obj.get(\"row\")\n        col = pos_obj.get(\"col\")\n        energy = agent_obj.get(\"energy\")\n        age = agent_obj.get(\"age\")\n        direction = agent_obj.get(\"direction\")\n\n        pos = Position(row=int(row), col=int(col))\n        agent = Agent(energy=int(energy), age=int(age), direction=int(direction))\n        agents_out.append((pos, agent))\n\n    # Enforce determinism: WorldState expects agents sorted by Position.\n    agents_out.sort(key=lambda pa: (pa[0].row, pa[0].col))\n\n    return WorldState(\n        width=int(width),\n        height=int(height),\n        step_number=int(step_number),\n        seed=int(seed),\n        agents=tuple(agents_out),\n    )\n\n\ndef save_checkpoint(state: WorldState, path: str) -> None:\n    \"\"\"Serialize a WorldState to JSON on disk.\n\n    Requirements:\n      - JSON only (no pickle)\n      - sorted keys\n      - 2-space indent\n      - lossless round-trip for WorldState\n    \"\"\"\n\n    obj = _state_to_obj(state)\n    text = json.dumps(obj, sort_keys=True, indent=2)\n    # Ensure trailing newline for POSIX-friendly text files.\n    if not text.endswith(\"\\n\"):\n        text += \"\\n\"\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(text)\n\n\ndef load_checkpoint(path: str) -> WorldState:\n    \"\"\"Load a WorldState from a JSON checkpoint on disk.\"\"\"\n\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        obj = json.load(f)\n    return _obj_to_state(obj)\n",
      "path": "worldsim/checkpoint.py"
    }
  ]
}
