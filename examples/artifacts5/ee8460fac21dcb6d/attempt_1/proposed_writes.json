{
  "summary": "Added comprehensive support module tests covering stats metrics and CSV output, ASCII rendering dimensions/placement/determinism, and checkpoint JSON round-trips including simulation resume equivalence.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "import os\nimport tempfile\n\nfrom worldsim.checkpoint import load_checkpoint, save_checkpoint\nfrom worldsim.render_ascii import render_ascii\nfrom worldsim.stats import StatsCollector\nfrom worldsim.types import Agent, Position, SimConfig, StepResult, WorldState\nfrom worldsim.world import World, create_world\n\n\ndef _mk_state(\n    *,\n    width: int = 4,\n    height: int = 3,\n    step_number: int = 0,\n    seed: int = 123,\n    agents: list[tuple[Position, Agent]] | None = None,\n) -> WorldState:\n    if agents is None:\n        agents = []\n    # WorldState expects agents sorted by Position for determinism.\n    agents_sorted = tuple(sorted(agents, key=lambda pa: (pa[0].row, pa[0].col)))\n    return WorldState(\n        width=width,\n        height=height,\n        step_number=step_number,\n        seed=seed,\n        agents=agents_sorted,\n    )\n\n\ndef _mk_step_result(state: WorldState, *, births: int = 0, deaths: int = 0, movements: int = 0) -> StepResult:\n    return StepResult(world=state, births=births, deaths=deaths, movements=movements)\n\n\n# -----------------\n# Stats (3 tests)\n# -----------------\n\ndef test_stats_record_population_and_density() -> None:\n    state = _mk_state(\n        width=4,\n        height=5,\n        step_number=7,\n        agents=[\n            (Position(0, 0), Agent(energy=10, age=0, direction=1)),\n            (Position(4, 3), Agent(energy=1, age=2, direction=2)),\n        ],\n    )\n    sr = _mk_step_result(state, births=1, deaths=0, movements=2)\n\n    sc = StatsCollector()\n    m = sc.record(sr)\n\n    assert m.step_number == 7\n    assert m.population == 2\n    assert m.density == 2 / (4 * 5)\n\n\ndef test_stats_to_csv_header_and_row_count() -> None:\n    sc = StatsCollector()\n\n    s0 = _mk_state(width=2, height=2, step_number=0, agents=[])\n    s1 = _mk_state(\n        width=2,\n        height=2,\n        step_number=1,\n        agents=[(Position(0, 1), Agent(energy=3, age=0, direction=0))],\n    )\n    s2 = _mk_state(\n        width=2,\n        height=2,\n        step_number=2,\n        agents=[\n            (Position(0, 1), Agent(energy=3, age=0, direction=0)),\n            (Position(1, 0), Agent(energy=7, age=1, direction=3)),\n        ],\n    )\n\n    sc.record(_mk_step_result(s0))\n    sc.record(_mk_step_result(s1, births=1))\n    sc.record(_mk_step_result(s2, deaths=1))\n\n    csv_text = sc.to_csv()\n    lines = csv_text.splitlines()\n\n    assert lines[0] == \"step_number,population,births,deaths,avg_energy,density\"\n    # header + 3 rows\n    assert len(lines) == 1 + 3\n\n\ndef test_stats_avg_energy_zero_when_population_zero() -> None:\n    state = _mk_state(width=3, height=3, step_number=0, agents=[])\n    sc = StatsCollector()\n    m = sc.record(_mk_step_result(state))\n    assert m.population == 0\n    assert m.avg_energy == 0.0\n\n\n# -----------------\n# ASCII render (3 tests)\n# -----------------\n\ndef test_render_ascii_dimensions() -> None:\n    state = _mk_state(width=6, height=4, agents=[])\n    out = render_ascii(state)\n    lines = out.split(\"\\n\")\n    assert len(lines) == 4\n    assert all(len(line) == 6 for line in lines)\n\n\ndef test_render_ascii_agent_positions_and_characters() -> None:\n    # width=5, height=3\n    # Place:\n    #  - '@' at (0,0) energy 6\n    #  - 'o' at (1,2) energy 5\n    #  - 'x' at (2,4) energy 0\n    state = _mk_state(\n        width=5,\n        height=3,\n        agents=[\n            (Position(0, 0), Agent(energy=6, age=0, direction=0)),\n            (Position(1, 2), Agent(energy=5, age=0, direction=1)),\n            (Position(2, 4), Agent(energy=0, age=0, direction=2)),\n        ],\n    )\n    out = render_ascii(state)\n    lines = out.split(\"\\n\")\n\n    assert lines[0] == \"@....\"\n    assert lines[1] == \"..o..\"\n    assert lines[2] == \"....x\"\n\n\ndef test_render_ascii_determinism_same_state_renders_identically() -> None:\n    state = _mk_state(\n        width=4,\n        height=2,\n        agents=[\n            (Position(0, 3), Agent(energy=2, age=0, direction=0)),\n            (Position(1, 0), Agent(energy=9, age=0, direction=0)),\n        ],\n    )\n    out1 = render_ascii(state)\n    out2 = render_ascii(state)\n    assert out1 == out2\n\n\n# -----------------\n# Checkpoint (4 tests)\n# -----------------\n\ndef test_checkpoint_round_trip_save_then_load_equals_original() -> None:\n    state = _mk_state(\n        width=7,\n        height=6,\n        step_number=12,\n        seed=999,\n        agents=[\n            (Position(0, 0), Agent(energy=10, age=3, direction=2)),\n            (Position(5, 6), Agent(energy=1, age=0, direction=1)),\n            (Position(2, 4), Agent(energy=7, age=9, direction=0)),\n        ],\n    )\n\n    d = tempfile.mkdtemp()\n    path = os.path.join(d, \"checkpoint.json\")\n\n    save_checkpoint(state, path)\n    loaded = load_checkpoint(path)\n\n    assert loaded == state\n\n\ndef test_checkpoint_round_trip_with_empty_agents() -> None:\n    state = _mk_state(width=3, height=3, step_number=0, seed=1, agents=[])\n\n    d = tempfile.mkdtemp()\n    path = os.path.join(d, \"empty.json\")\n\n    save_checkpoint(state, path)\n    loaded = load_checkpoint(path)\n\n    assert loaded == state\n    assert loaded.agents == ()\n\n\ndef test_checkpoint_preserves_all_agent_fields_energy_age_direction() -> None:\n    state = _mk_state(\n        width=4,\n        height=4,\n        step_number=2,\n        seed=42,\n        agents=[\n            (Position(1, 1), Agent(energy=123, age=45, direction=3)),\n            (Position(0, 2), Agent(energy=-1, age=0, direction=0)),\n        ],\n    )\n\n    d = tempfile.mkdtemp()\n    path = os.path.join(d, \"fields.json\")\n\n    save_checkpoint(state, path)\n    loaded = load_checkpoint(path)\n\n    assert loaded.width == state.width\n    assert loaded.height == state.height\n    assert loaded.step_number == state.step_number\n    assert loaded.seed == state.seed\n\n    # Compare per-position to ensure fields preserved.\n    loaded_map = {pos: agent for pos, agent in loaded.agents}\n    orig_map = {pos: agent for pos, agent in state.agents}\n    assert loaded_map.keys() == orig_map.keys()\n    for pos in orig_map:\n        assert loaded_map[pos].energy == orig_map[pos].energy\n        assert loaded_map[pos].age == orig_map[pos].age\n        assert loaded_map[pos].direction == orig_map[pos].direction\n\n\ndef test_checkpoint_resume_matches_continuous_run() -> None:\n    # Run 10 steps straight\n    config = SimConfig(\n        width=8,\n        height=6,\n        seed=2024,\n        initial_density=0.35,\n        max_steps=100,\n    )\n\n    w_full = create_world(config)\n    for _ in range(10):\n        w_full.step()\n    state_full_10 = w_full.get_state()\n\n    # Run 5 steps, checkpoint, load into new World, run 5 more\n    w_part = create_world(config)\n    for _ in range(5):\n        w_part.step()\n    state_5 = w_part.get_state()\n\n    d = tempfile.mkdtemp()\n    path = os.path.join(d, \"resume.json\")\n    save_checkpoint(state_5, path)\n    loaded_5 = load_checkpoint(path)\n\n    w_resumed = World(config=config, state=loaded_5)\n    for _ in range(5):\n        w_resumed.step()\n    state_resumed_10 = w_resumed.get_state()\n\n    assert state_resumed_10 == state_full_10\n",
      "path": "tests/test_support.py"
    }
  ]
}
