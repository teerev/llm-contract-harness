{
  "summary": "Added lifesim/checkpoint.py implementing JSON-based save_checkpoint and load_checkpoint for lossless WorldState round-tripping, including serialization/deserialization of Position/Agent NamedTuples and stable sorting of agents.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nimport json\nfrom typing import Any, Dict, List, Tuple\n\nfrom .types import Agent, Position, WorldState\n\n\ndef _agents_to_jsonable(\n    agents: Tuple[Tuple[Position, Agent], ...],\n) -> List[Dict[str, Any]]:\n    \"\"\"Convert agents tuple into a JSON-serializable list of dicts.\"\"\"\n    out: List[Dict[str, Any]] = []\n    for pos, agent in agents:\n        out.append(\n            {\n                \"pos\": {\"row\": int(pos.row), \"col\": int(pos.col)},\n                \"agent\": {\n                    \"energy\": int(agent.energy),\n                    \"age\": int(agent.age),\n                    \"direction\": int(agent.direction),\n                },\n            }\n        )\n    return out\n\n\ndef _agents_from_jsonable(\n    data: Any,\n) -> Tuple[Tuple[Position, Agent], ...]:\n    \"\"\"Reconstruct agents tuple from JSON data and return it sorted.\"\"\"\n    if not isinstance(data, list):\n        raise ValueError(\"Invalid checkpoint: 'agents' must be a list\")\n\n    agents_list: List[Tuple[Position, Agent]] = []\n    for item in data:\n        if not isinstance(item, dict):\n            raise ValueError(\"Invalid checkpoint: each agent entry must be an object\")\n\n        pos_d = item.get(\"pos\")\n        agent_d = item.get(\"agent\")\n        if not isinstance(pos_d, dict) or not isinstance(agent_d, dict):\n            raise ValueError(\"Invalid checkpoint: agent entry must contain 'pos' and 'agent' objects\")\n\n        pos = Position(row=int(pos_d[\"row\"]), col=int(pos_d[\"col\"]))\n        agent = Agent(\n            energy=int(agent_d[\"energy\"]),\n            age=int(agent_d[\"age\"]),\n            direction=int(agent_d[\"direction\"]),\n        )\n        agents_list.append((pos, agent))\n\n    # Ensure deterministic ordering for lossless round-trip equality.\n    agents_list.sort(key=lambda pa: (pa[0].row, pa[0].col, pa[1].energy, pa[1].age, pa[1].direction))\n    return tuple(agents_list)\n\n\ndef save_checkpoint(state: WorldState, path: str) -> None:\n    \"\"\"Serialize a WorldState to a JSON file.\"\"\"\n    payload: Dict[str, Any] = {\n        \"width\": int(state.width),\n        \"height\": int(state.height),\n        \"step_number\": int(state.step_number),\n        \"seed\": int(state.seed),\n        \"agents\": _agents_to_jsonable(state.agents),\n    }\n\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(payload, f, sort_keys=True, indent=2)\n        f.write(\"\\n\")\n\n\ndef load_checkpoint(path: str) -> WorldState:\n    \"\"\"Load a WorldState from a JSON checkpoint file.\"\"\"\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        payload = json.load(f)\n\n    if not isinstance(payload, dict):\n        raise ValueError(\"Invalid checkpoint: root must be an object\")\n\n    width = int(payload[\"width\"])\n    height = int(payload[\"height\"])\n    step_number = int(payload[\"step_number\"])\n    seed = int(payload[\"seed\"])\n    agents = _agents_from_jsonable(payload.get(\"agents\"))\n\n    return WorldState(\n        width=width,\n        height=height,\n        step_number=step_number,\n        seed=seed,\n        agents=agents,\n    )\n",
      "path": "lifesim/checkpoint.py"
    }
  ]
}
