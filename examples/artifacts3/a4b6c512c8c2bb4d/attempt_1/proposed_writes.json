{
  "summary": "Added lifesim/render.py implementing a pure deterministic render_ascii(WorldState) that outputs an ASCII grid with agent energy-based glyphs.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nfrom typing import Dict\n\nfrom .types import Position, WorldState\n\n\ndef render_ascii(state: WorldState) -> str:\n    \"\"\"Render a WorldState as an ASCII grid.\n\n    Each cell is one character:\n      - '.' for empty\n      - '@' for agents with energy > 5\n      - 'o' for agents with energy 1-5\n      - 'x' for agents with energy <= 0\n\n    Rows are separated by '\\n' with no trailing newline.\n    \"\"\"\n\n    def glyph_for_energy(energy: int) -> str:\n        if energy > 5:\n            return \"@\"\n        if energy >= 1:\n            return \"o\"\n        return \"x\"\n\n    # Build a position->glyph map for O(1) lookup while rendering.\n    # If multiple agents occupy the same position, the last one in the tuple wins.\n    agent_glyphs: Dict[Position, str] = {\n        pos: glyph_for_energy(agent.energy) for (pos, agent) in state.agents\n    }\n\n    lines = []\n    for r in range(state.height):\n        row_chars = []\n        for c in range(state.width):\n            row_chars.append(agent_glyphs.get(Position(r, c), \".\"))\n        lines.append(\"\".join(row_chars))\n    return \"\\n\".join(lines)\n",
      "path": "lifesim/render.py"
    }
  ]
}
