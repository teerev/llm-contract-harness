{
  "summary": "Added deterministic core simulation pytest suite covering world creation, stepping determinism, invariants (collisions, population accounting, non-negative metrics, energy>0), and corrected age monotonicity check to track agents by identity (age) rather than position to avoid false failures due to births into vacated cells. Updated verify.sh to run pytest after compileall.",
  "writes": [
    {
      "base_sha256": "87945f9eaa188bf4f4412f9522bb7f40e85e870de32d966c7aee07c921ac5887",
      "content": "#!/usr/bin/env bash\nset -euo pipefail\npython -m compileall -q .\npython -m pytest -q\n",
      "path": "scripts/verify.sh"
    },
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nfrom typing import Dict, Iterable, Tuple\n\nfrom lifesim.types import Agent, Position, SimConfig, StepResult, WorldState\nfrom lifesim.world import create_world\n\n\ndef _positions(state: WorldState) -> Tuple[Position, ...]:\n    return tuple(pos for pos, _agent in state.agents)\n\n\ndef _agents_by_pos(state: WorldState) -> Dict[Position, Agent]:\n    return dict(state.agents)\n\n\ndef _energies(state: WorldState) -> Tuple[int, ...]:\n    return tuple(agent.energy for _pos, agent in state.agents)\n\n\ndef _ages(state: WorldState) -> Tuple[int, ...]:\n    return tuple(agent.age for _pos, agent in state.agents)\n\n\ndef _assert_no_collisions(state: WorldState) -> None:\n    pos = _positions(state)\n    assert len(set(pos)) == len(pos)\n\n\ndef test_create_world_returns_worldstate_with_dimensions_step0_and_agents_for_density_gt0():\n    config = SimConfig(width=12, height=8, seed=123, initial_density=0.6)\n    world = create_world(config)\n    state = world.get_state()\n\n    assert isinstance(state, WorldState)\n    assert state.width == config.width\n    assert state.height == config.height\n    assert state.step_number == 0\n    assert state.seed == config.seed\n    assert len(state.agents) > 0\n\n\ndef test_create_world_determinism_same_config_produces_identical_worldstate():\n    config = SimConfig(width=10, height=7, seed=999, initial_density=0.35)\n    w1 = create_world(config)\n    w2 = create_world(config)\n\n    assert w1.get_state() == w2.get_state()\n\n\ndef test_step_increments_step_number_by_1():\n    config = SimConfig(width=9, height=9, seed=5, initial_density=0.4)\n    world = create_world(config)\n    before = world.get_state()\n    result = world.step()\n\n    assert result.world.step_number == before.step_number + 1\n\n\ndef test_step_determinism_same_initial_state_twice_produces_identical_stepresult():\n    config = SimConfig(width=11, height=6, seed=42, initial_density=0.5)\n    w1 = create_world(config)\n    w2 = create_world(config)\n\n    r1 = w1.step()\n    r2 = w2.step()\n\n    assert isinstance(r1, StepResult)\n    assert r1 == r2\n\n\ndef test_no_cell_collisions_after_step():\n    config = SimConfig(width=15, height=10, seed=101, initial_density=0.7)\n    world = create_world(config)\n\n    for _ in range(5):\n        result = world.step()\n        _assert_no_collisions(result.world)\n\n\ndef test_stepresult_births_deaths_movements_are_non_negative():\n    config = SimConfig(width=14, height=9, seed=202, initial_density=0.5)\n    world = create_world(config)\n\n    for _ in range(10):\n        result = world.step()\n        assert result.births >= 0\n        assert result.deaths >= 0\n        assert result.movements >= 0\n\n\ndef test_multi_step_determinism_10_steps_from_same_seed_compare_final_states():\n    config = SimConfig(width=16, height=12, seed=77, initial_density=0.4)\n    w1 = create_world(config)\n    w2 = create_world(config)\n\n    for _ in range(10):\n        w1.step()\n        w2.step()\n\n    assert w1.get_state() == w2.get_state()\n\n\ndef test_population_invariant_population_before_plus_births_minus_deaths_equals_after_each_step():\n    config = SimConfig(width=13, height=11, seed=88, initial_density=0.55)\n    world = create_world(config)\n\n    prev = world.get_state()\n    for _ in range(10):\n        result = world.step()\n        curr = result.world\n\n        population_before = len(prev.agents)\n        population_after = len(curr.agents)\n        assert population_before + result.births - result.deaths == population_after\n\n        prev = curr\n\n\ndef test_energy_bounds_all_living_agents_have_energy_gt_0():\n    config = SimConfig(width=12, height=12, seed=303, initial_density=0.6)\n    world = create_world(config)\n\n    for _ in range(10):\n        result = world.step()\n        assert all(e > 0 for e in _energies(result.world))\n\n\ndef test_age_monotonicity_agent_ages_only_increase_across_steps():\n    \"\"\"Ages should never decrease for continuing agents.\n\n    We cannot track identity directly (agents are keyed by Position and can move).\n    However, the ruleset increments age by exactly 1 for all existing agents, and\n    births introduce new agents with age=0.\n\n    Therefore, the multiset of ages after a step must equal:\n      {a+1 for a in previous ages} plus {0 repeated births times}.\n\n    This avoids false failures where a birth occurs into a cell that was occupied\n    in the previous step (position-based comparison is not valid).\n    \"\"\"\n\n    config = SimConfig(width=13, height=9, seed=77, initial_density=0.4)\n    world = create_world(config)\n\n    prev = world.get_state()\n    for _ in range(10):\n        result = world.step()\n        curr = result.world\n\n        expected_ages = sorted([a + 1 for a in _ages(prev)] + [0] * result.births)\n        actual_ages = sorted(_ages(curr))\n        assert actual_ages == expected_ages\n\n        prev = curr\n",
      "path": "tests/test_simulation.py"
    }
  ]
}
