{
  "summary": "Created core simulation engine with World class and deterministic stepping, plus default ruleset implementing movement, energy updates, reproduction, and death on a toroidal grid.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nimport random\nfrom typing import Dict, List, Tuple\n\nfrom lifesim.types import Agent, Position, SimConfig\n\n\ndef _wrap_pos(row: int, col: int, width: int, height: int) -> Position:\n    return Position(row % height, col % width)\n\n\ndef _move_target(pos: Position, direction: int, width: int, height: int) -> Position:\n    # 0=N:row-1, 1=E:col+1, 2=S:row+1, 3=W:col-1\n    if direction == 0:\n        return _wrap_pos(pos.row - 1, pos.col, width, height)\n    if direction == 1:\n        return _wrap_pos(pos.row, pos.col + 1, width, height)\n    if direction == 2:\n        return _wrap_pos(pos.row + 1, pos.col, width, height)\n    # direction == 3\n    return _wrap_pos(pos.row, pos.col - 1, width, height)\n\n\ndef _adjacent_positions(pos: Position, width: int, height: int) -> List[Position]:\n    # N, E, S, W\n    return [\n        _wrap_pos(pos.row - 1, pos.col, width, height),\n        _wrap_pos(pos.row, pos.col + 1, width, height),\n        _wrap_pos(pos.row + 1, pos.col, width, height),\n        _wrap_pos(pos.row, pos.col - 1, width, height),\n    ]\n\n\ndef default_ruleset(\n    agents: Dict[Position, Agent],\n    width: int,\n    height: int,\n    config: SimConfig,\n    rng: random.Random,\n) -> Tuple[Dict[Position, Agent], int, int, int]:\n    \"\"\"Default simulation rules.\n\n    Returns: (new_agents_dict, births_count, deaths_count, movements_count)\n    \"\"\"\n\n    # Phase 1: age + move + energy update\n    movements = 0\n    new_agents: Dict[Position, Agent] = {}\n\n    for pos in sorted(agents.keys()):\n        agent = agents[pos]\n\n        # 1. Age\n        age = agent.age + 1\n        energy = agent.energy\n        direction = agent.direction\n\n        # 2. Move (if target empty in the *new* map)\n        target = _move_target(pos, direction, width, height)\n        if target not in new_agents:\n            new_pos = target\n            if new_pos != pos:\n                movements += 1\n        else:\n            new_pos = pos\n\n        # Randomize direction after move attempt\n        direction = rng.randint(0, 3)\n\n        # Energy update\n        energy = energy - config.move_cost + config.energy_gain\n\n        new_agents[new_pos] = Agent(energy=energy, age=age, direction=direction)\n\n    # Phase 2: reproduction\n    births = 0\n    # Iterate over a stable snapshot of positions (sorted) so reproduction order is deterministic.\n    for pos in sorted(list(new_agents.keys())):\n        parent = new_agents.get(pos)\n        if parent is None:\n            continue\n        if parent.energy < config.reproduction_threshold:\n            continue\n\n        candidates = [p for p in _adjacent_positions(pos, width, height) if p not in new_agents]\n        if not candidates:\n            continue\n\n        child_pos = rng.choice(candidates)\n        child = Agent(energy=config.reproduction_cost, age=0, direction=rng.randint(0, 3))\n        new_agents[child_pos] = child\n\n        # Parent pays reproduction cost\n        new_agents[pos] = Agent(\n            energy=parent.energy - config.reproduction_cost,\n            age=parent.age,\n            direction=parent.direction,\n        )\n        births += 1\n\n    # Phase 3: death\n    deaths = 0\n    survivors: Dict[Position, Agent] = {}\n    for pos in sorted(new_agents.keys()):\n        agent = new_agents[pos]\n        if agent.energy <= 0 or agent.age > config.max_age:\n            deaths += 1\n            continue\n        survivors[pos] = agent\n\n    return survivors, births, deaths, movements\n",
      "path": "lifesim/rules.py"
    },
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nimport random\nfrom typing import Dict, Optional\n\nfrom lifesim.types import Agent, Position, SimConfig, StepResult, WorldState\n\n\ndef create_world(config: SimConfig) -> \"World\":\n    rng = random.Random(config.seed)\n    agents: Dict[Position, Agent] = {}\n\n    # Row-major order placement\n    for row in range(config.height):\n        for col in range(config.width):\n            if rng.random() < config.initial_density:\n                pos = Position(row, col)\n                agents[pos] = Agent(\n                    energy=config.initial_energy,\n                    age=0,\n                    direction=rng.randint(0, 3),\n                )\n\n    state = WorldState(\n        width=config.width,\n        height=config.height,\n        step_number=0,\n        seed=config.seed,\n        agents=tuple((pos, agents[pos]) for pos in sorted(agents.keys())),\n    )\n    return World(config=config, state=state)\n\n\nclass World:\n    def __init__(self, config: SimConfig, state: WorldState, ruleset=None):\n        self.config = config\n        self._state = state\n        self._agents: Dict[Position, Agent] = {pos: agent for (pos, agent) in state.agents}\n\n        if ruleset is None:\n            from lifesim.rules import default_ruleset\n\n            self._ruleset = default_ruleset\n        else:\n            self._ruleset = ruleset\n\n    def step(self) -> StepResult:\n        step_number = self._state.step_number\n        # Deterministic per-step RNG for resumability\n        rng = random.Random(self.config.seed * 6364136223846793005 + step_number)\n\n        new_agents, births, deaths, movements = self._ruleset(\n            self._agents,\n            self._state.width,\n            self._state.height,\n            self.config,\n            rng,\n        )\n\n        new_state = WorldState(\n            width=self._state.width,\n            height=self._state.height,\n            step_number=step_number + 1,\n            seed=self._state.seed,\n            agents=tuple((pos, new_agents[pos]) for pos in sorted(new_agents.keys())),\n        )\n\n        self._agents = new_agents\n        self._state = new_state\n\n        return StepResult(world=new_state, births=births, deaths=deaths, movements=movements)\n\n    def get_state(self) -> WorldState:\n        return WorldState(\n            width=self._state.width,\n            height=self._state.height,\n            step_number=self._state.step_number,\n            seed=self._state.seed,\n            agents=tuple((pos, self._agents[pos]) for pos in sorted(self._agents.keys())),\n        )\n",
      "path": "lifesim/world.py"
    }
  ]
}
