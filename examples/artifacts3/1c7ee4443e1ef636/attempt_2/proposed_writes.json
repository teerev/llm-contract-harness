{
  "summary": "Added comprehensive integration tests for stats, ASCII rendering, checkpoint round-trips, and deterministic end-to-end simulation; fixed checkpoint round-trip test to compare canonicalized agent ordering (since loader returns sorted agents) while also asserting all agent fields are preserved.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nimport os\nimport tempfile\n\nfrom lifesim.checkpoint import load_checkpoint, save_checkpoint\nfrom lifesim.render import render_ascii\nfrom lifesim.stats import StatsCollector\nfrom lifesim.types import Agent, Position, SimConfig, StepResult, WorldState\nfrom lifesim.world import World, create_world\n\n\ndef _make_state(\n    *,\n    width: int,\n    height: int,\n    step_number: int,\n    seed: int,\n    agents: tuple[tuple[Position, Agent], ...],\n) -> WorldState:\n    return WorldState(\n        width=width,\n        height=height,\n        step_number=step_number,\n        seed=seed,\n        agents=agents,\n    )\n\n\ndef _canonicalize_state(state: WorldState) -> WorldState:\n    # World.get_state() and load_checkpoint() both use sorted agents for determinism.\n    return WorldState(\n        width=state.width,\n        height=state.height,\n        step_number=state.step_number,\n        seed=state.seed,\n        agents=tuple(sorted(state.agents, key=lambda kv: kv[0])),\n    )\n\n\n# -----------------\n# Stats tests\n# -----------------\n\ndef test_stats_record_returns_tickmetrics_with_correct_population() -> None:\n    state = _make_state(\n        width=3,\n        height=2,\n        step_number=1,\n        seed=123,\n        agents=(\n            (Position(0, 0), Agent(energy=10, age=0, direction=0)),\n            (Position(1, 2), Agent(energy=3, age=1, direction=1)),\n        ),\n    )\n    step_result = StepResult(world=state, births=0, deaths=0, movements=0)\n\n    sc = StatsCollector()\n    metrics = sc.record(step_result)\n\n    assert metrics.population == 2\n    assert metrics.step_number == 1\n\n\ndef test_stats_to_csv_header_and_row_count_after_n_records() -> None:\n    sc = StatsCollector()\n\n    for i in range(3):\n        state = _make_state(\n            width=2,\n            height=2,\n            step_number=i,\n            seed=1,\n            agents=((Position(0, 0), Agent(energy=5, age=i, direction=0)),),\n        )\n        sc.record(StepResult(world=state, births=0, deaths=0, movements=0))\n\n    csv_text = sc.to_csv()\n    lines = csv_text.splitlines()\n\n    assert lines[0] == \"step_number,population,births,deaths,avg_energy\"\n    # header + N rows\n    assert len(lines) == 1 + 3\n\n\ndef test_stats_avg_energy_is_zero_when_population_is_zero() -> None:\n    state = _make_state(\n        width=4,\n        height=4,\n        step_number=0,\n        seed=0,\n        agents=(),\n    )\n    sc = StatsCollector()\n    metrics = sc.record(StepResult(world=state, births=0, deaths=0, movements=0))\n\n    assert metrics.population == 0\n    assert metrics.avg_energy == 0.0\n\n\n# -----------------\n# Render tests\n# -----------------\n\ndef test_render_ascii_dimensions_height_lines_each_width_chars() -> None:\n    state = _make_state(\n        width=5,\n        height=3,\n        step_number=0,\n        seed=0,\n        agents=(),\n    )\n    out = render_ascii(state)\n    lines = out.split(\"\\n\")\n\n    assert len(lines) == 3\n    assert all(len(line) == 5 for line in lines)\n\n\ndef test_render_ascii_agents_and_empty_cells_glyphs() -> None:\n    # energy > 5 => '@', energy 1-5 => 'o', empty => '.'\n    state = _make_state(\n        width=4,\n        height=2,\n        step_number=0,\n        seed=0,\n        agents=(\n            (Position(0, 1), Agent(energy=6, age=0, direction=0)),\n            (Position(1, 3), Agent(energy=1, age=0, direction=0)),\n        ),\n    )\n    out = render_ascii(state)\n    lines = out.split(\"\\n\")\n\n    assert lines[0] == \".@..\"\n    assert lines[1] == \"...o\"\n\n\ndef test_render_ascii_determinism_same_state_renders_identically() -> None:\n    state = _make_state(\n        width=6,\n        height=4,\n        step_number=7,\n        seed=42,\n        agents=(\n            (Position(2, 2), Agent(energy=10, age=3, direction=2)),\n            (Position(0, 5), Agent(energy=2, age=1, direction=1)),\n        ),\n    )\n\n    assert render_ascii(state) == render_ascii(state)\n\n\n# -----------------\n# Checkpoint tests\n# -----------------\n\ndef test_checkpoint_round_trip_identical_worldstate() -> None:\n    # Note: load_checkpoint returns agents sorted for deterministic equality.\n    # So compare against a canonicalized (sorted) version of the original.\n    state = _make_state(\n        width=7,\n        height=5,\n        step_number=9,\n        seed=999,\n        agents=(\n            (Position(4, 6), Agent(energy=12, age=7, direction=2)),\n            (Position(0, 0), Agent(energy=1, age=0, direction=0)),\n        ),\n    )\n\n    tmpdir = tempfile.mkdtemp()\n    path = os.path.join(tmpdir, \"checkpoint.json\")\n\n    save_checkpoint(state, path)\n    loaded = load_checkpoint(path)\n\n    assert loaded == _canonicalize_state(state)\n\n\ndef test_checkpoint_round_trip_empty_agents_tuple() -> None:\n    state = _make_state(\n        width=3,\n        height=3,\n        step_number=0,\n        seed=5,\n        agents=(),\n    )\n\n    tmpdir = tempfile.mkdtemp()\n    path = os.path.join(tmpdir, \"checkpoint.json\")\n\n    save_checkpoint(state, path)\n    loaded = load_checkpoint(path)\n\n    assert loaded == state\n    assert loaded.agents == ()\n\n\ndef test_checkpoint_round_trip_preserves_all_agent_fields() -> None:\n    state = _make_state(\n        width=5,\n        height=5,\n        step_number=2,\n        seed=77,\n        agents=(\n            (Position(3, 4), Agent(energy=9, age=11, direction=3)),\n            (Position(1, 0), Agent(energy=0, age=2, direction=1)),\n        ),\n    )\n\n    tmpdir = tempfile.mkdtemp()\n    path = os.path.join(tmpdir, \"checkpoint.json\")\n\n    save_checkpoint(state, path)\n    loaded = load_checkpoint(path)\n\n    # Compare as dicts to ignore ordering and focus on field preservation.\n    assert dict(loaded.agents) == dict(state.agents)\n\n\n# -----------------\n# End-to-end tests\n# -----------------\n\ndef test_end_to_end_determinism_same_seed_same_final_state() -> None:\n    config = SimConfig(width=10, height=8, seed=123, initial_density=0.25, max_steps=100)\n\n    w1 = create_world(config)\n    w2 = create_world(config)\n\n    for _ in range(10):\n        w1.step()\n        w2.step()\n\n    assert w1.get_state() == w2.get_state()\n\n\ndef test_checkpoint_resume_matches_running_straight() -> None:\n    config = SimConfig(width=12, height=7, seed=2024, initial_density=0.3)\n\n    # Run 10 steps straight\n    w_straight = create_world(config)\n    for _ in range(10):\n        w_straight.step()\n    final_straight = w_straight.get_state()\n\n    # Run 5 steps, checkpoint, load into new World, run 5 more\n    w_part = create_world(config)\n    for _ in range(5):\n        w_part.step()\n    mid_state = w_part.get_state()\n\n    tmpdir = tempfile.mkdtemp()\n    path = os.path.join(tmpdir, \"resume.json\")\n    save_checkpoint(mid_state, path)\n    loaded_mid = load_checkpoint(path)\n\n    w_resumed = World(config=config, state=loaded_mid)\n    for _ in range(5):\n        w_resumed.step()\n\n    assert w_resumed.get_state() == final_straight\n",
      "path": "tests/test_integration.py"
    }
  ]
}
