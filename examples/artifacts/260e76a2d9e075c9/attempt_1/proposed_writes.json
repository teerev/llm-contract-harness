{
  "summary": "Added lsysviz/render.py implementing deterministic PNG rendering of line segments using Pillow with bounding-box fit and padding; no changes to existing types.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nfrom typing import Iterable\n\nfrom PIL import Image, ImageDraw\n\nfrom .types import Segment\n\n\ndef _bbox_from_segments(segments: Iterable[Segment]) -> tuple[float, float, float, float] | None:\n    it = iter(segments)\n    try:\n        first = next(it)\n    except StopIteration:\n        return None\n\n    min_x = min(first.x0, first.x1)\n    max_x = max(first.x0, first.x1)\n    min_y = min(first.y0, first.y1)\n    max_y = max(first.y0, first.y1)\n\n    for s in it:\n        min_x = min(min_x, s.x0, s.x1)\n        max_x = max(max_x, s.x0, s.x1)\n        min_y = min(min_y, s.y0, s.y1)\n        max_y = max(max_y, s.y0, s.y1)\n\n    return (min_x, min_y, max_x, max_y)\n\n\ndef render_to_png(segments: list[Segment], width: int, height: int, output_path: str) -> None:\n    \"\"\"Render line segments to a PNG file.\n\n    Creates a white RGB image, fits all segment coordinates into the image with\n    padding, draws black 1px lines, and saves deterministically.\n    \"\"\"\n\n    if width <= 0 or height <= 0:\n        raise ValueError(\"width and height must be positive\")\n\n    img = Image.new(\"RGB\", (int(width), int(height)), (255, 255, 255))\n\n    if not segments:\n        img.save(output_path, format=\"PNG\", optimize=False)\n        return\n\n    bbox = _bbox_from_segments(segments)\n    if bbox is None:\n        img.save(output_path, format=\"PNG\", optimize=False)\n        return\n\n    min_x, min_y, max_x, max_y = bbox\n\n    # Padding: 10% margin on each side.\n    pad_x = 0.1 * width\n    pad_y = 0.1 * height\n    avail_w = max(1.0, width - 2.0 * pad_x)\n    avail_h = max(1.0, height - 2.0 * pad_y)\n\n    span_x = max_x - min_x\n    span_y = max_y - min_y\n\n    # Handle degenerate cases (all points same x and/or y).\n    if span_x == 0.0 and span_y == 0.0:\n        scale = 1.0\n    elif span_x == 0.0:\n        scale = avail_h / span_y\n    elif span_y == 0.0:\n        scale = avail_w / span_x\n    else:\n        scale = min(avail_w / span_x, avail_h / span_y)\n\n    # Center the content within the padded area.\n    content_w = span_x * scale\n    content_h = span_y * scale\n    offset_x = pad_x + (avail_w - content_w) / 2.0\n    offset_y = pad_y + (avail_h - content_h) / 2.0\n\n    def map_point(x: float, y: float) -> tuple[float, float]:\n        # Map to image coordinates; invert Y so larger Y is up in world coords.\n        px = offset_x + (x - min_x) * scale\n        py = (height - 1) - (offset_y + (y - min_y) * scale)\n        return (px, py)\n\n    draw = ImageDraw.Draw(img)\n    for s in segments:\n        x0, y0 = map_point(s.x0, s.y0)\n        x1, y1 = map_point(s.x1, s.y1)\n        draw.line((x0, y0, x1, y1), fill=(0, 0, 0), width=1)\n\n    # Deterministic output: avoid encoder-side optimizations that may vary.\n    img.save(output_path, format=\"PNG\", optimize=False)\n",
      "path": "lsysviz/render.py"
    }
  ]
}
