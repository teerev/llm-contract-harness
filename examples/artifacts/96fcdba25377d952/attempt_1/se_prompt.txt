You are a software engineer. Propose DIRECT FILE WRITES to implement the requested changes.

## Work Order
Title: Wire CLI to full expand-turtle-render pipeline
Intent: Edit lsysviz/cli.py to add command-line arguments and wire them through the expand, turtle, and render modules to produce a PNG from L-system parameters.

## Allowed Files (you may ONLY write to these paths)
  - lsysviz/__init__.py
  - lsysviz/cli.py
  - lsysviz/expand.py
  - lsysviz/render.py
  - lsysviz/turtle.py
  - lsysviz/types.py

## Forbidden
  - Do not modify lsysviz/__init__.py
  - Do not modify lsysviz/types.py
  - Do not modify lsysviz/expand.py
  - Do not modify lsysviz/turtle.py
  - Do not modify lsysviz/render.py

## Notes
Edit ONLY lsysviz/cli.py. Keep the existing --version flag. Add these required arguments to build_parser(): --axiom (str, required), --rule (str, repeatable via action='append', required, format 'SYMBOL=REPLACEMENT' e.g. 'F=FF+F'), --iterations (int, required), --angle (float, required, degrees), --step (float, required, step length), --output (str, required, output PNG path). Add optional: --width (int, default 800), --height (int, default 600). In main(), after parsing: if --version, print version and return 0. Otherwise: parse each --rule string by splitting on the first '=' to build a rules dict, construct a Grammar, call expand(), call interpret(), call render_to_png(), return 0. All other files are context-only — do NOT modify them.

## Current File Contents
Use the sha256 shown below as the `base_sha256` value in your writes.
For files that do not exist yet, use the sha256 of empty bytes: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

### lsysviz/__init__.py
exists: True
sha256: 20c8e430ededc2143396e553a3c67aac4ec483ef54efdfcb18a31cb162ca0646
```
__version__ = '0.1.0'

```

### lsysviz/cli.py
exists: True
sha256: 4e766a6ec14429cfa57589e4f9e585c1570464e59526c9dcaffe9d8dd9de3b73
```
import argparse
from . import __version__


def build_parser():
    parser = argparse.ArgumentParser(description='L-system Visualizer')
    parser.add_argument('--version', action='store_true', help='Show version information')
    return parser


def main(argv=None):
    parser = build_parser()
    args = parser.parse_args(argv)

    if args.version:
        print(__version__)
    else:
        parser.print_help()

    return 0

```

### lsysviz/expand.py
exists: True
sha256: a7165283f3c641812faf8e51bb0fb560b02967ba9216f036395ec0226d22e88e
```
from lsysviz.types import Grammar

def expand(grammar: Grammar, iterations: int) -> str:
    current_string = grammar.axiom
    for _ in range(iterations):
        next_string = []
        for char in current_string:
            if char in grammar.rules:
                next_string.append(grammar.rules[char])
            else:
                next_string.append(char)
        current_string = ''.join(next_string)
    return current_string

```

### lsysviz/render.py
exists: True
sha256: c8365209be7f4cb10c8f2aeed6430630fc2cc2603b291d18977d1d6bbbec3733
```
from PIL import Image, ImageDraw
from lsysviz.types import Segment


def render_to_png(segments: list[Segment], width: int, height: int, output_path: str) -> None:
    # Create a white RGB image
    image = Image.new('RGB', (width, height), 'white')
    draw = ImageDraw.Draw(image)

    if not segments:
        # Save a blank white image if no segments
        image.save(output_path, 'PNG')
        return

    # Calculate bounding box of all segments
    min_x = min(min(segment.x0, segment.x1) for segment in segments)
    max_x = max(max(segment.x0, segment.x1) for segment in segments)
    min_y = min(min(segment.y0, segment.y1) for segment in segments)
    max_y = max(max(segment.y0, segment.y1) for segment in segments)

    # Calculate scale and translation to fit segments within the image with padding
    padding = 0.1  # 10% padding
    scale_x = (1 - 2 * padding) * width / (max_x - min_x) if max_x > min_x else 1
    scale_y = (1 - 2 * padding) * height / (max_y - min_y) if max_y > min_y else 1
    scale = min(scale_x, scale_y)

    translate_x = padding * width - min_x * scale
    translate_y = padding * height - min_y * scale

    # Draw each segment as a black line
    for segment in segments:
        x0 = segment.x0 * scale + translate_x
        y0 = segment.y0 * scale + translate_y
        x1 = segment.x1 * scale + translate_x
        y1 = segment.y1 * scale + translate_y
        draw.line((x0, y0, x1, y1), fill='black', width=1)

    # Save the image as PNG
    image.save(output_path, 'PNG')

```

### lsysviz/turtle.py
exists: True
sha256: 53887844e71138448d3fea6f2f93980d1153d7a9a975bd805d1b11602eed1c3d
```
from math import cos, sin, radians
from lsysviz.types import Segment

def interpret(lstring: str, angle_deg: float, step_length: float) -> list[Segment]:
    position_stack = []
    x, y = 0.0, 0.0
    angle = 90.0  # Start facing upwards
    segments = []

    for command in lstring:
        if command == 'F':
            new_x = x + step_length * cos(radians(angle))
            new_y = y + step_length * sin(radians(angle))
            segments.append(Segment(x, y, new_x, new_y))
            x, y = new_x, new_y
        elif command == '+':
            angle += angle_deg
        elif command == '-':
            angle -= angle_deg
        elif command == '[':
            position_stack.append((x, y, angle))
        elif command == ']':
            x, y, angle = position_stack.pop()

    return segments

```

### lsysviz/types.py
exists: True
sha256: acd6556ff72f55ba25dd18c7da8508b359c59357c1fc59a50e77300c801c52d4
```
from typing import NamedTuple, Dict

class Grammar(NamedTuple):
    axiom: str
    rules: Dict[str, str]

class Segment(NamedTuple):
    x0: float
    y0: float
    x1: float
    y1: float

```

## Required Output Format (STRICT — no deviations)
Output ONLY a single JSON object with exactly two keys:
  "summary"  — a brief description of what you changed
  "writes"   — an array of objects, each with:
      "path"        — relative file path (must be in allowed files)
      "base_sha256" — hex SHA256 of the file's current content (from the sha256 values shown above)
      "content"     — the COMPLETE new file content as a string

Do NOT wrap the JSON in markdown fences or add any other text.
Every write must contain the FULL file content, not a partial edit.