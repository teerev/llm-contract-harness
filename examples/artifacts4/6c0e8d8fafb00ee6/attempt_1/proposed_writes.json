{
  "summary": "Added worldsim/checkpoint.py implementing JSON-based save_checkpoint and load_checkpoint for lossless WorldState round-tripping, including conversion of agents tuple to JSON-friendly lists and reconstruction into sorted NamedTuple structures. No changes to worldsim/types.py.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nimport json\nfrom typing import Any, Dict, List, Tuple\n\nfrom worldsim.types import Agent, Position, WorldState\n\n\ndef _state_to_obj(state: WorldState) -> Dict[str, Any]:\n    # Convert agents from Tuple[Tuple[Position, Agent], ...] into JSON-friendly\n    # list-of-lists: [[pos_obj, agent_obj], ...]\n    agents_list: List[List[Dict[str, int]]] = []\n    for pos, agent in state.agents:\n        agents_list.append(\n            [\n                {\"row\": int(pos.row), \"col\": int(pos.col)},\n                {\n                    \"energy\": int(agent.energy),\n                    \"age\": int(agent.age),\n                    \"direction\": int(agent.direction),\n                },\n            ]\n        )\n\n    return {\n        \"width\": int(state.width),\n        \"height\": int(state.height),\n        \"step_number\": int(state.step_number),\n        \"seed\": int(state.seed),\n        \"agents\": agents_list,\n    }\n\n\ndef save_checkpoint(state: WorldState, path: str) -> None:\n    \"\"\"Serialize a WorldState to JSON at the given path.\n\n    Notes:\n      - Uses sorted keys and 2-space indentation.\n      - Converts agents tuple into a list-of-lists for JSON compatibility.\n    \"\"\"\n    obj = _state_to_obj(state)\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(obj, f, sort_keys=True, indent=2)\n        f.write(\"\\n\")\n\n\ndef _obj_to_state(obj: Dict[str, Any]) -> WorldState:\n    agents_in = obj.get(\"agents\", [])\n    agents_out: List[Tuple[Position, Agent]] = []\n\n    for pair in agents_in:\n        # Expected: [ {\"row\":...,\"col\":...}, {\"energy\":...,\"age\":...,\"direction\":...} ]\n        if not isinstance(pair, list) or len(pair) != 2:\n            raise ValueError(\"Invalid checkpoint format: agent entry must be a 2-item list\")\n        pos_obj, agent_obj = pair\n        if not isinstance(pos_obj, dict) or not isinstance(agent_obj, dict):\n            raise ValueError(\"Invalid checkpoint format: agent entry must contain dicts\")\n\n        pos = Position(row=int(pos_obj[\"row\"]), col=int(pos_obj[\"col\"]))\n        agent = Agent(\n            energy=int(agent_obj[\"energy\"]),\n            age=int(agent_obj[\"age\"]),\n            direction=int(agent_obj[\"direction\"]),\n        )\n        agents_out.append((pos, agent))\n\n    # Ensure determinism: WorldState requires agents sorted by Position.\n    agents_sorted = tuple(sorted(agents_out, key=lambda pa: (pa[0].row, pa[0].col)))\n\n    return WorldState(\n        width=int(obj[\"width\"]),\n        height=int(obj[\"height\"]),\n        step_number=int(obj[\"step_number\"]),\n        seed=int(obj[\"seed\"]),\n        agents=agents_sorted,\n    )\n\n\ndef load_checkpoint(path: str) -> WorldState:\n    \"\"\"Load a WorldState from a JSON checkpoint at the given path.\"\"\"\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        obj = json.load(f)\n    if not isinstance(obj, dict):\n        raise ValueError(\"Invalid checkpoint format: root must be an object\")\n    return _obj_to_state(obj)\n",
      "path": "worldsim/checkpoint.py"
    }
  ]
}
