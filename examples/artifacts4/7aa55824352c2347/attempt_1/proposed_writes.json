{
  "summary": "Added worldsim/world.py implementing World class and create_world factory. World manages internal agent dict, deterministic per-step RNG, calls default_ruleset, and returns immutable sorted WorldState snapshots.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nimport random\nfrom typing import Callable, Dict, Optional, Tuple\n\nfrom .rules import default_ruleset\nfrom .types import Agent, Position, SimConfig, StepResult, WorldState\n\n\nRulesetFn = Callable[\n    [Dict[Position, Agent], int, int, SimConfig, random.Random],\n    Tuple[Dict[Position, Agent], int, int, int],\n]\n\n\ndef create_world(config: SimConfig) -> \"World\":\n    \"\"\"Create a new World with agents placed deterministically from config.seed.\n\n    Placement:\n      - Iterate cells in row-major order.\n      - If rng.random() < config.initial_density, place an agent with:\n          energy=config.initial_energy, age=0, direction=rng.randint(0,3)\n\n    Notes:\n      - Uses a local random.Random instance (does not touch global RNG state).\n    \"\"\"\n\n    rng = random.Random(config.seed)\n    agents: Dict[Position, Agent] = {}\n\n    for row in range(config.height):\n        for col in range(config.width):\n            if rng.random() < config.initial_density:\n                pos = Position(row, col)\n                agents[pos] = Agent(\n                    energy=config.initial_energy,\n                    age=0,\n                    direction=rng.randint(0, 3),\n                )\n\n    state = WorldState(\n        width=config.width,\n        height=config.height,\n        step_number=0,\n        seed=config.seed,\n        agents=tuple((p, agents[p]) for p in sorted(agents)),\n    )\n    return World(config=config, state=state, ruleset=None)\n\n\nclass World:\n    def __init__(\n        self,\n        config: SimConfig,\n        state: WorldState,\n        ruleset: Optional[RulesetFn] = None,\n    ) -> None:\n        self.config = config\n        self._width = state.width\n        self._height = state.height\n        self._seed = state.seed\n        self._step_number = state.step_number\n\n        # Unpack immutable state into internal mutable mapping.\n        self._agents: Dict[Position, Agent] = {pos: agent for pos, agent in state.agents}\n\n        self._ruleset: RulesetFn = default_ruleset if ruleset is None else ruleset\n\n    def step(self) -> StepResult:\n        \"\"\"Advance the simulation by one step using the configured ruleset.\"\"\"\n\n        # Deterministic per-step RNG for resumability.\n        rng = random.Random(self.config.seed * 6364136223846793005 + self._step_number)\n\n        new_agents, births, deaths, movements = self._ruleset(\n            self._agents,\n            self._width,\n            self._height,\n            self.config,\n            rng,\n        )\n\n        self._agents = new_agents\n        self._step_number += 1\n\n        world_state = self.get_state()\n        return StepResult(\n            world=world_state,\n            births=births,\n            deaths=deaths,\n            movements=movements,\n        )\n\n    def get_state(self) -> WorldState:\n        \"\"\"Return an immutable snapshot of the current world state.\"\"\"\n\n        return WorldState(\n            width=self._width,\n            height=self._height,\n            step_number=self._step_number,\n            seed=self._seed,\n            agents=tuple((p, self._agents[p]) for p in sorted(self._agents)),\n        )\n",
      "path": "worldsim/world.py"
    }
  ]
}
