{
  "summary": "Added mazegen/generate.py implementing a deterministic, seeded recursive-backtracker perfect maze generator returning a Maze with frozenset passages; no changes to existing types.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nimport random\nfrom typing import List, Set, Tuple\n\nfrom .types import Maze, Position\n\n\ndef generate(width: int, height: int, seed: int) -> Maze:\n    \"\"\"Generate a deterministic perfect rectangular maze.\n\n    Uses a recursive-backtracker (depth-first) algorithm starting at (0, 0).\n    Neighbor order is shuffled using a local RNG instance seeded with `seed`.\n\n    Passages are stored as undirected edges represented by ordered pairs:\n    (min(pos_a, pos_b), max(pos_a, pos_b)).\n    \"\"\"\n    if width <= 0 or height <= 0:\n        raise ValueError(\"width and height must be positive\")\n\n    rng = random.Random(seed)\n\n    start = Position(0, 0)\n    end = Position(height - 1, width - 1)\n\n    visited: Set[Position] = set()\n    passages: Set[Tuple[Position, Position]] = set()\n\n    def neighbors(p: Position) -> List[Position]:\n        r, c = p\n        out: List[Position] = []\n        if r > 0:\n            out.append(Position(r - 1, c))\n        if r + 1 < height:\n            out.append(Position(r + 1, c))\n        if c > 0:\n            out.append(Position(r, c - 1))\n        if c + 1 < width:\n            out.append(Position(r, c + 1))\n        return out\n\n    def carve(a: Position, b: Position) -> None:\n        edge = (a, b) if a <= b else (b, a)\n        passages.add(edge)\n\n    def dfs(p: Position) -> None:\n        visited.add(p)\n        nbrs = neighbors(p)\n        rng.shuffle(nbrs)\n        for n in nbrs:\n            if n in visited:\n                continue\n            carve(p, n)\n            dfs(n)\n\n    dfs(start)\n\n    # For a perfect maze (spanning tree) on W*H cells, edges must be W*H - 1.\n    # This should hold for the DFS backtracker on a connected grid.\n    expected = width * height - 1\n    if len(passages) != expected:\n        raise RuntimeError(\n            f\"maze generation failed: expected {expected} passages, got {len(passages)}\"\n        )\n\n    return Maze(\n        width=width,\n        height=height,\n        seed=seed,\n        start=start,\n        end=end,\n        passages=frozenset(passages),\n    )\n",
      "path": "mazegen/generate.py"
    }
  ]
}
