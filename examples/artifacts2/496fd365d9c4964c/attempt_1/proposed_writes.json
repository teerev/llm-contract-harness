{
  "summary": "Added mazegen/render.py implementing pure deterministic ASCII maze rendering with optional solution path overlay, following the specified wall and cell conventions.",
  "writes": [
    {
      "base_sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": "from __future__ import annotations\n\nfrom typing import Iterable, Set, Tuple\n\nfrom .types import Maze, Position, Solution\n\n\ndef _normalize_edge(a: Position, b: Position) -> Tuple[Position, Position]:\n    return (a, b) if a <= b else (b, a)\n\n\ndef _passage_set(maze: Maze) -> Set[Tuple[Position, Position]]:\n    # Treat passages as undirected edges.\n    return {_normalize_edge(a, b) for (a, b) in maze.passages}\n\n\ndef _in_bounds(maze: Maze, p: Position) -> bool:\n    return 0 <= p.row < maze.height and 0 <= p.col < maze.width\n\n\ndef render_ascii(maze: Maze, solution: Solution | None = None) -> str:\n    \"\"\"Render a maze as ASCII art.\n\n    Conventions:\n      - '+' at grid intersections\n      - '---' for horizontal walls, '|' for vertical walls\n      - '   ' for open cell interiors\n      - If a passage exists between adjacent cells, omit the wall between them.\n      - If solution is provided and solution.found is True, mark each cell on the\n        path with ' * ' (asterisk centered in the cell interior).\n\n    The output has (2 * height + 1) lines.\n    \"\"\"\n\n    w, h = maze.width, maze.height\n    passages = _passage_set(maze)\n\n    path_cells: Set[Position] = set()\n    if solution is not None and solution.found:\n        # Only mark in-bounds positions; ignore any out-of-bounds entries.\n        path_cells = {p for p in solution.path if _in_bounds(maze, p)}\n\n    lines: list[str] = []\n\n    for r in range(h):\n        # Top boundary of row r\n        top_parts: list[str] = ['+']\n        for c in range(w):\n            cell = Position(r, c)\n            above = Position(r - 1, c)\n            if r > 0 and _normalize_edge(cell, above) in passages:\n                top_parts.append('   ')\n            else:\n                top_parts.append('---')\n            top_parts.append('+')\n        lines.append(''.join(top_parts))\n\n        # Cell interior row r with vertical walls\n        mid_parts: list[str] = []\n        for c in range(w):\n            cell = Position(r, c)\n            left = Position(r, c - 1)\n\n            if c == 0:\n                mid_parts.append('|')\n            else:\n                if _normalize_edge(cell, left) in passages:\n                    mid_parts.append(' ')\n                else:\n                    mid_parts.append('|')\n\n            mid_parts.append(' * ' if cell in path_cells else '   ')\n\n        # Right boundary wall\n        mid_parts.append('|')\n        lines.append(''.join(mid_parts))\n\n    # Bottom boundary\n    bottom_parts: list[str] = ['+']\n    for c in range(w):\n        bottom_parts.append('---')\n        bottom_parts.append('+')\n    lines.append(''.join(bottom_parts))\n\n    return '\\n'.join(lines) + '\\n'\n",
      "path": "mazegen/render.py"
    }
  ]
}
